<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0a">
<title>Iconoclast: Find Your Guide</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    background: #0a0a0a;
    min-height: 100%;
    min-height: 100dvh;
    overflow: hidden;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-overflow-scrolling: auto;
    overscroll-behavior: none;
  }

  body {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Press Start 2P', monospace;
  }

  #game-wrapper {
    position: relative;
    width: 95vw;
    height: 71.25vw;
    max-width: 960px;
    max-height: 720px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    -ms-interpolation-mode: nearest-neighbor;
  }

  canvas {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    -ms-interpolation-mode: nearest-neighbor;
    border: 4px solid #2a2a2a;
    border-radius: 4px;
    touch-action: none;
  }

  #mobile-controls {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 100;
    padding: 10px 16px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    touch-action: none;
  }

  .controls-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 500px;
    margin: 0 auto;
  }

  .dpad {
    display: grid;
    grid-template-columns: 56px 56px 56px;
    grid-template-rows: 56px 56px 56px;
    gap: 3px;
    touch-action: none;
  }

  .dpad button {
    background: rgba(255,255,255,0.18);
    border: 2px solid rgba(255,255,255,0.35);
    border-radius: 8px;
    color: white;
    font-size: 20px;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: pointer;
  }

  .dpad button:active { background: rgba(255,255,255,0.4); }
  .dpad .empty { background: none; border: none; pointer-events: none; }

  #action-btn {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: rgba(100,200,100,0.3);
    border: 3px solid rgba(100,200,100,0.6);
    color: white;
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    display: none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: pointer;
    flex-shrink: 0;
  }

  #action-btn:active { background: rgba(100,200,100,0.5); }

  @media (hover: none) and (pointer: coarse) {
    #mobile-controls { display: block; }
    #action-btn { display: block; }

    body {
      justify-content: flex-start;
      padding-top: max(8px, env(safe-area-inset-top));
    }

    #game-wrapper {
      width: 100vw;
      height: 75vw;
      max-width: 100vw;
      max-height: calc(100dvh - 200px);
    }

    canvas {
      border: none;
      border-radius: 0;
    }
  }

  /* Small phones (iPhone SE, etc) */
  @media (hover: none) and (pointer: coarse) and (max-height: 700px) {
    #game-wrapper {
      height: 75vw;
      max-height: calc(100dvh - 185px);
    }
    .dpad {
      grid-template-columns: 48px 48px 48px;
      grid-template-rows: 48px 48px 48px;
    }
    #action-btn { width: 68px; height: 68px; font-size: 12px; }
  }
</style>
</head>
<body>

<div id="game-wrapper">
  <canvas id="game" width="640" height="480"></canvas>
</div>

<div id="mobile-controls">
  <div class="controls-row">
    <div class="dpad">
      <div class="empty"></div>
      <button id="btn-up">▲</button>
      <div class="empty"></div>
      <button id="btn-left">◄</button>
      <div class="empty"></div>
      <button id="btn-right">►</button>
      <div class="empty"></div>
      <button id="btn-down">▼</button>
      <div class="empty"></div>
    </div>
    <button id="action-btn">A</button>
  </div>
</div>

<script>
// ========================================
// ICONOCLAST: FIND YOUR GUIDE
// A retro RPG financial planning journey
// ========================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 640, H = 480;
const TILE = 32;
const COLS = W / TILE; // 20
const ROWS = H / TILE; // 15

// Disable anti-aliasing for crisp pixels
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;
ctx.msImageSmoothingEnabled = false;

// Color palette
const PAL = {
  black: '#0a0a0a',
  dark: '#1a1a2e',
  mid: '#16213e',
  accent: '#e2b714',
  green: '#4a7c59',
  darkGreen: '#2d5a3f',
  red: '#8b3a3a',
  blue: '#3a5a8b',
  lightBlue: '#6a9fd8',
  white: '#e8e8e8',
  gray: '#6a6a7a',
  lightGray: '#a8a8b8',
  skin: '#f0c8a0',
  brown: '#6e4930',
  purple: '#6a3a8a',
  orange: '#d4853a',
  teal: '#3a8a7a',
  wizardBlue: '#4a90d9',
  wizardGold: '#f4d03f',
};

// ========== CHIPTUNE AUDIO ENGINE ==========
let audioCtx = null;
let currentMusic = null;
let musicGain = null;
let musicPlaying = false;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    musicGain = audioCtx.createGain();
    musicGain.gain.value = 0.12;
    musicGain.connect(audioCtx.destination);
  }
  // Resume if suspended (browser autoplay policy)
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

// Play a single chiptune note
function playNote(freq, duration, type = 'square', gainVal = 0.1, delay = 0) {
  if (!audioCtx || audioCtx.state === 'suspended') return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(gainVal, audioCtx.currentTime + delay);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(audioCtx.currentTime + delay);
  osc.stop(audioCtx.currentTime + delay + duration);
}

// Play SFX
function playSfxStep() {
  playNote(200 + Math.random() * 60, 0.05, 'square', 0.03);
}

function playSfxInteract() {
  playNote(440, 0.08, 'square', 0.08);
  playNote(660, 0.08, 'square', 0.08, 0.08);
}

function playSfxQuizSelect() {
  playNote(330, 0.06, 'square', 0.06);
}

function playSfxQuizConfirm() {
  playNote(440, 0.1, 'square', 0.1);
  playNote(554, 0.1, 'square', 0.1, 0.1);
  playNote(660, 0.15, 'square', 0.1, 0.2);
}

function playSfxTransition() {
  for (let i = 0; i < 8; i++) {
    playNote(200 + i * 50, 0.15, 'triangle', 0.06, i * 0.06);
  }
}

// Musical stinger for zone entry (plays during chapter card)
function playZoneStinger(zone) {
  const stingers = [
    [262, 294, 330, 392],     // Uncertainville: hopeful rising
    [220, 208, 196, 175],     // Media Swamp: descending tension
    [294, 330, 294, 262],     // Opinion Forest: wandering/confused
    [196, 175, 165, 196],     // Worry Mountains: haunting resolve
    [330, 440, 524, 660],     // Wizard Tower: magical ascent
  ];
  const s = stingers[zone] || stingers[0];
  s.forEach((f, i) => {
    playNote(f, 0.2, 'triangle', 0.05, i * 0.15);
  });
}

// ========== ZONE MUSIC LOOPS ==========
// Each zone gets a distinct mood via looping arpeggios

let musicInterval = null;

function stopMusic() {
  if (musicInterval) {
    clearInterval(musicInterval);
    musicInterval = null;
  }
  musicPlaying = false;
}

function startZoneMusic(zone) {
  stopMusic();
  if (!audioCtx) return;
  musicPlaying = true;

  const bpm = [110, 90, 100, 70, 60][zone] || 100;
  const interval = (60 / bpm) * 1000 / 2; // eighth notes
  let step = 0;

  // Zone 0: Uncertainville — curious, hopeful, simple melody
  const melodies = [
    // Uncertainville: C major arpeggio, gentle & wondering
    { notes: [262, 330, 392, 330, 262, 294, 349, 294, 262, 330, 392, 440, 392, 330, 294, 262],
      type: 'square', gain: 0.05, bass: [131, 131, 147, 147, 131, 131, 147, 147, 131, 131, 147, 147, 165, 165, 131, 131] },
    // Media Swamp: dissonant, tense, minor key with chromatic tension
    { notes: [220, 233, 262, 233, 220, 208, 196, 208, 220, 262, 277, 262, 233, 220, 208, 196],
      type: 'sawtooth', gain: 0.04, bass: [110, 110, 104, 104, 110, 110, 98, 98, 110, 110, 104, 104, 98, 98, 110, 110] },
    // Opinion Forest: chaotic, shifting between keys, slightly comedic
    { notes: [294, 330, 370, 330, 294, 349, 392, 349, 330, 370, 294, 262, 294, 330, 370, 392],
      type: 'square', gain: 0.05, bass: [147, 147, 165, 165, 175, 175, 147, 147, 165, 165, 147, 147, 131, 131, 147, 147] },
    // Worry Mountains: slow, haunting, minor with sustained feel
    { notes: [196, 0, 233, 0, 220, 0, 196, 0, 175, 0, 196, 0, 220, 0, 233, 0],
      type: 'triangle', gain: 0.06, bass: [98, 0, 110, 0, 98, 0, 88, 0, 98, 0, 110, 0, 98, 0, 88, 0] },
    // Wizard Tower: warm, magical, resolving, major with sparkle
    { notes: [330, 392, 494, 392, 330, 440, 524, 440, 330, 392, 494, 587, 524, 494, 440, 392],
      type: 'triangle', gain: 0.06, bass: [165, 165, 196, 196, 220, 220, 196, 196, 165, 165, 196, 196, 220, 220, 165, 165] },
  ];

  const m = melodies[zone] || melodies[0];

  musicInterval = setInterval(() => {
    if (!musicPlaying) return;
    const noteFreq = m.notes[step % m.notes.length];
    const bassFreq = m.bass[step % m.bass.length];
    if (noteFreq > 0) {
      playNote(noteFreq, interval / 1000 * 1.5, m.type, m.gain);
    }
    if (bassFreq > 0) {
      playNote(bassFreq, interval / 1000 * 2, 'triangle', m.gain * 0.6);
    }
    step++;
  }, interval);
}

// ========== GAME STATE ==========
let gameState = 'intro'; // intro, title, charSelect, playing, dialogue, quiz, transition, minigame, stats, victory, ending
let currentZone = 0;
let player = {
  x: 7, y: 12,       // grid position (logical tile)
  px: 7 * 32, py: 12 * 32,  // pixel position (visual, smooth)
  dir: 0, frame: 0, moving: false,
  moveProgress: 0,    // 0 to 1 interpolation
  targetX: 7, targetY: 12,
  isMoving: false      // currently animating between tiles
};
const MOVE_SPEED = 0.14; // fraction of tile per frame (~7 frames per tile)
let dialogueQueue = [];
let currentDialogue = null;
let dialogueCharIndex = 0;
let dialogueTimer = 0;
let quizData = null;
let quizSelection = 0;
let quizAnswers = [];
let transitionAlpha = 0;
let transitionDir = 0; // 0=none, 1=fadeOut, 2=holdCard, 3=fadeIn
let transitionCallback = null;
let chapterCardTimer = 0;
const CHAPTER_CARD_DURATION = 100; // ~1.7 seconds at 60fps

// Zone taglines for chapter title cards
const ZONE_TAGLINES = [
  "Congrats. You have no plan.",
  "Brought to you by people\n   who profit from your panic.",
  "Unsolicited advice is free.\n   Worth every penny.",
  "Your brain is not your friend.",
  "Most people quit before this."
];
let titleSelection = 0;
let endingPhase = 0;
let endingTimer = 0;
let npcs = [];
let frameCount = 0;
let keysDown = {};
let moveTimer = 0;
let interactCooldown = 0;

// ========== INTRO SEQUENCE ==========
let introTimer = 0;
const INTRO_DURATION = 180; // 3 seconds at 60fps

// ========== AMBIENT PARTICLES ==========
let ambientParticles = [];
function spawnAmbientParticles(zone) {
  ambientParticles = [];
  const count = zone === 4 ? 25 : 18;
  for (let i = 0; i < count; i++) {
    ambientParticles.push({
      x: Math.random() * W,
      y: Math.random() * H,
      vx: (Math.random() - 0.5) * 0.3,
      vy: zone === 3 ? Math.random() * 0.4 + 0.2 : (Math.random() - 0.5) * 0.2,
      size: Math.random() * 3 + 1,
      life: 999,
      phase: Math.random() * Math.PI * 2, // for sinusoidal drift
      zone: zone
    });
  }
}

function updateAmbientParticles() {
  for (const p of ambientParticles) {
    p.x += p.vx + Math.sin(frameCount * 0.01 + p.phase) * 0.15;
    p.y += p.vy;
    // Wrap around screen
    if (p.x < -5) p.x = W + 5;
    if (p.x > W + 5) p.x = -5;
    if (p.y < -5) p.y = H + 5;
    if (p.y > H + 5) p.y = -5;
  }
}

function drawAmbientParticles(zone) {
  for (const p of ambientParticles) {
    const flicker = Math.sin(frameCount * 0.04 + p.phase) * 0.3 + 0.7;
    if (zone === 0) {
      // Fireflies - warm yellow-green, pulsing
      ctx.fillStyle = `rgba(180, 220, 80, ${flicker * 0.5})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      // Glow
      ctx.fillStyle = `rgba(180, 220, 80, ${flicker * 0.15})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
      ctx.fill();
    } else if (zone === 1) {
      // Static/glitch - red-white flicker, rectangular
      const glitch = Math.random() > 0.92;
      if (glitch) {
        ctx.fillStyle = `rgba(255, ${Math.random() > 0.5 ? 60 : 200}, ${Math.random() > 0.5 ? 60 : 200}, 0.7)`;
        ctx.fillRect(p.x, p.y, Math.random() * 12 + 2, 1);
      } else {
        ctx.fillStyle = `rgba(200, 80, 80, ${flicker * 0.25})`;
        ctx.fillRect(p.x, p.y, p.size, p.size * 0.5);
      }
    } else if (zone === 2) {
      // Falling leaves - amber/brown, drifting
      ctx.fillStyle = `rgba(180, 140, 60, ${flicker * 0.4})`;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.sin(frameCount * 0.02 + p.phase) * 0.5);
      ctx.fillRect(-p.size, -p.size * 0.5, p.size * 2, p.size);
      ctx.restore();
    } else if (zone === 3) {
      // Snow/mist - white, slowly falling
      ctx.fillStyle = `rgba(200, 200, 240, ${flicker * 0.35})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 0.8, 0, Math.PI * 2);
      ctx.fill();
    } else if (zone === 4) {
      // Magical sparkles - gold, twinkling
      const twinkle = Math.sin(frameCount * 0.08 + p.phase) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(244, 208, 63, ${twinkle * 0.6})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * twinkle, 0, Math.PI * 2);
      ctx.fill();
      // Cross sparkle
      if (twinkle > 0.7) {
        ctx.fillRect(p.x - p.size * 2, p.y - 0.5, p.size * 4, 1);
        ctx.fillRect(p.x - 0.5, p.y - p.size * 2, 1, p.size * 4);
      }
    }
  }
}

// ========== PARALLAX BACKGROUNDS ==========
let parallaxOffset = { x: 0, y: 0 };

function drawParallaxLayer(zone) {
  // Slow-scrolling background layer behind the main map
  const px = parallaxOffset.x * 0.3;
  const py = parallaxOffset.y * 0.3;
  const t = frameCount * 0.5;

  if (zone === 0) {
    // Drifting clouds
    ctx.fillStyle = 'rgba(60, 80, 60, 0.15)';
    for (let i = 0; i < 4; i++) {
      const cx = ((i * 150 + t * 0.3 + px) % (W + 120)) - 60;
      const cy = 30 + i * 70 + Math.sin(t * 0.005 + i) * 10 + py * 0.5;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 50 + i * 10, 15 + i * 3, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  } else if (zone === 1) {
    // Scrolling scan lines / static noise background
    ctx.fillStyle = 'rgba(40, 60, 40, 0.08)';
    for (let y = 0; y < H; y += 6) {
      const offset = Math.sin(y * 0.1 + t * 0.02) * 3;
      ctx.fillRect(offset, y + py * 0.1, W, 2);
    }
  } else if (zone === 2) {
    // Distant tree silhouettes
    ctx.fillStyle = 'rgba(30, 30, 15, 0.3)';
    for (let i = 0; i < 8; i++) {
      const tx = ((i * 75 + px * 0.4) % (W + 40)) - 20;
      const ty = 20 + Math.sin(i * 2.3) * 30 + py * 0.3;
      // Triangle tree
      ctx.beginPath();
      ctx.moveTo(tx, ty + 40);
      ctx.lineTo(tx + 15, ty);
      ctx.lineTo(tx + 30, ty + 40);
      ctx.fill();
    }
  } else if (zone === 3) {
    // Distant mountain range, layered
    ctx.fillStyle = 'rgba(20, 20, 45, 0.25)';
    ctx.beginPath();
    ctx.moveTo(0, 120);
    for (let x = 0; x <= W; x += 20) {
      const h = Math.sin(x * 0.015 + 1) * 40 + Math.sin(x * 0.007) * 25 + py * 0.2;
      ctx.lineTo(x, 60 + h);
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.fill();

    ctx.fillStyle = 'rgba(25, 25, 55, 0.2)';
    ctx.beginPath();
    ctx.moveTo(0, 140);
    for (let x = 0; x <= W; x += 15) {
      const h = Math.sin(x * 0.012 + 3) * 35 + Math.sin(x * 0.009 + 1) * 20 + py * 0.15;
      ctx.lineTo(x, 80 + h);
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.fill();
  }
  // Zone 4 has its own starfield, no parallax needed
}

// ========== STATS TRACKING ==========
let gameStartTime = 0;
let npcsEncountered = 0;
let totalSteps = 0;

// ========== FEAR BOSS VISUAL STATE ==========
let fearHealth = 1.0; // visual health for smooth drain
let fearShake = 0;
let fearCracks = [];
let fearEyes = [];

function initFearBoss() {
  fearHealth = 1.0;
  fearShake = 0;
  fearCracks = [];
  fearEyes = [];
  // Generate random eye positions within the fear entity
  for (let i = 0; i < 5; i++) {
    fearEyes.push({
      x: (Math.random() - 0.5) * 50,
      y: (Math.random() - 0.5) * 40,
      size: Math.random() * 6 + 4,
      blinkTimer: Math.random() * 200,
      lookX: 0, lookY: 0
    });
  }
}

function addFearCrack() {
  const angle = Math.random() * Math.PI * 2;
  const len = Math.random() * 25 + 15;
  fearCracks.push({
    x: Math.cos(angle) * 10,
    y: Math.sin(angle) * 10,
    angle: angle,
    len: len,
    branches: Math.floor(Math.random() * 3) + 1
  });
}

// ========== MUSIC TRANSITION SYSTEM ==========
let musicFadeTarget = 1.0;
let musicFadeSpeed = 0.02;
let pendingZoneMusic = -1;

function crossfadeToZone(zone) {
  pendingZoneMusic = zone;
  musicFadeTarget = 0; // fade out current
  musicFadeSpeed = 0.03;
}

function updateMusicFade() {
  if (!musicGain) return;
  const current = musicGain.gain.value;
  if (pendingZoneMusic >= 0 && current <= 0.005) {
    // Fully faded out — switch music
    startZoneMusic(pendingZoneMusic);
    pendingZoneMusic = -1;
    musicFadeTarget = 0.12; // fade back in
    musicFadeSpeed = 0.015;
    musicGain.gain.value = 0.001;
  }
  // Smooth fade
  if (Math.abs(current - musicFadeTarget) > 0.001) {
    const dir = musicFadeTarget > current ? 1 : -1;
    musicGain.gain.value = Math.max(0.001, Math.min(0.12, current + dir * musicFadeSpeed * 0.12));
  }
}

// ========== NEW: Insight counter, mini-game, confetti ==========
let insightCount = 0;
let minigameState = null; // null, 'active', 'won'
let minigameQuestion = 0;
let minigameSelection = 0;
let minigameWrongMsg = null;
let minigameWrongTimer = 0;
let confettiParticles = [];
let confettiTimer = 0;
let victoryTimer = 0;
let quizWrongMsg = null;
let quizWrongTimer = 0;

const MINIGAME_QUESTIONS = [
  {
    question: "FEAR screams: 'The market is\ncrashing! SELL EVERYTHING\nBEFORE IT'S TOO LATE!'",
    options: ["PANIC! SELL! SELL! SELL!", "Breathe. Check the plan.\nFear doesn't get a vote.", "Delete the app and pretend\nI never had money"],
    correct: 1,
    wrongMsg: "Fear LOVES that answer. Try again."
  },
  {
    question: "FEAR whispers: 'Your neighbor\njust 10x'd on crypto. You're\nfalling behind, loser.'",
    options: ["FOMO! All in on dogecoin!", "Cool story. Not my plan.", "Ask which influencer told\nthem to buy"],
    correct: 1,
    wrongMsg: "That's Fear talking. You're\nbetter than that. Again."
  },
  {
    question: "FEAR hisses: 'Nobody can be\ntrusted with your money.\nEspecially not YOU.'",
    options: ["Maybe Fear has a point...", "Fine, I'll just stuff cash\nunder the mattress forever", "Trust is earned. I'll find\nsomeone who earns it."],
    correct: 2,
    wrongMsg: "Fear is thrilled. That's\nnot a good sign. Try again."
  }
];

// Wrong-answer quips for zone quizzes
const QUIZ_WRONG_QUIPS = [
  ["That's the panic talking.\nLet's try again...", "Anxiety is loud but wrong.\nTry once more...", "Ignoring it is also a plan.\nA bad one. Try again..."],
  ["Confidence ≠ competence.\nTry again...", "Paralysis isn't a strategy.\nOne more try...", "DIY has its limits.\nTry again..."],
  ["That's your worry talking,\nnot reality. Try again...", "That's the fear loop.\nBreak it. Try again...", "That one cuts deep.\nBut you can do better..."]
];

// Life stage labels
const LIFE_STAGES = [
  "Just starting out (20s-30s)",
  "Building & growing (30s-40s)",
  "Protecting what I've built (50s+)"
];

// ========== CHARACTER ARCHETYPES ==========
const ARCHETYPES = [
  {
    name: "BEN",
    title: "The Frugalist",
    desc: "Clips coupons with surgical precision. Needs a plan, not a guilt trip.",
    sprite: 'ben',
    color: '#7ec87e', // green — earthy, careful
    tagline: "Every dollar has a job. Most of mine work overtime."
  },
  {
    name: "LUNA",
    title: "The Strategist",
    desc: "Has a spreadsheet for her spreadsheets. Needs signal, not more noise.",
    sprite: 'luna',
    color: '#6a9fd8', // blue — analytical, cool
    tagline: "I don't guess. I model."
  },
  {
    name: "MAX",
    title: "The Risk Seeker",
    desc: "Portfolio looks like a Vegas receipt. Needs guardrails before the next 'sure thing.'",
    sprite: 'max',
    color: '#d85454', // red — bold, aggressive
    tagline: "You miss 100% of the moonshots you don't take."
  },
  {
    name: "JORDAN",
    title: "The Lifestyle Maxxer",
    desc: "Credit score is a vibe. Spends boldly, plans... later. Needs autopilot. Yesterday.",
    sprite: 'jordan',
    color: '#f4d03f', // gold — flashy, charismatic
    tagline: "Life is the ROI. Everything else is a spreadsheet."
  },
  {
    name: "SAGE",
    title: "The Social Security Seer",
    desc: "Plays the long game. Has opinions about Roth ladders. Needs someone who keeps up.",
    sprite: 'sage',
    color: '#9a7fd8', // purple — wise, deliberate
    tagline: "Patience isn't passive. It's a strategy."
  }
];

let charSelectIndex = 0;
let selectedArchetype = null;
let charSelectAnimTimer = 0;

// ========== ZONE DEFINITIONS ==========
const ZONES = [
  // Zone 0: Uncertainville
  {
    name: "Uncertainville",
    bgColor: '#1a1a2e',
    music: null,
    map: null, // generated procedurally
    playerStart: { x: 10, y: 12 },
    exitTile: { x: 10, y: 1 },
    introDialogue: [
      "Welcome to UNCERTAINVILLE.\nPopulation: literally everyone\nat some point.",
      "You need a financial plan.\nYou've needed one for years.\nLet's stop pretending otherwise.",
      "The world ahead is loud,\nwrong, and very confident\nabout it.",
      "HEAD NORTH. Talk to people\nwith SPACE. Try not to cry."
    ],
    npcs: [
      { x: 5, y: 8, type: 'villager', lines: ["I've been googling\n'how to retire' for\nthree years straight.", "Still haven't opened\na Roth IRA. But I did\nbuy a boat."] },
      { x: 10, y: 10, type: 'villager', lines: ["Save 20%. No, 15%. Actually\n30%. You know what, just\ndon't eat avocado toast."] },
      { x: 3, y: 5, type: 'sign', lines: ["NORTH: Where your excuses\nrun out.\n\nGood luck."] },
      { x: 17, y: 7, type: 'sign', lines: ["HIDDEN WISDOM: The best time\nto start was 10 years ago.\nThe second best is before\nyou buy another gadget.", "     +1 Insight"], easterEgg: true },
    ]
  },
  // Zone 1: The Media Swamp
  {
    name: "The Media Swamp",
    bgColor: '#1a2e1a',
    playerStart: { x: 10, y: 13 },
    exitTile: { x: 10, y: 1 },
    introDialogue: [
      "You enter THE MEDIA SWAMP.",
      "Every screen is screaming.\nNone of them are screaming\nfor YOUR benefit.",
      "Remember: if it's free,\nyou're the product.\nIf it's scary, you're the\nrevenue."
    ],
    npcs: [
      { x: 3, y: 9, type: 'tv', lines: ["BREAKING: MARKETS IN FREEFALL!\nSELL EVERYTHING NOW!!!\n...brought to you by people\nwho sold yesterday."] },
      { x: 15, y: 7, type: 'tv', lines: ["EXPERT WARNS: You're NOT\nsaving enough for retirement!\n...Expert is 28 and lives\nwith his parents."] },
      { x: 6, y: 5, type: 'tv', lines: ["THIS ONE WEIRD TRICK will\n10X your portfolio!\n\nSpoiler: it's a scam."] },
      { x: 9, y: 11, type: 'tv', lines: ["RECESSION IMMINENT!\nIS YOUR MONEY SAFE?\n\nIt wasn't safe when you were\nwatching us instead of\nplanning."] },
      { x: 4, y: 4, type: 'reporter', lines: ["I get paid per click, not\nper truth. Nothing personal.", "My 401k? Oh, I have a\nfinancial planner for that.\nIronic, right?"] },
      { x: 16, y: 12, type: 'sign', lines: ["A sticky note reads:\n'If it bleeds, it leads.\nIf it scares, it shares.\nIf it trends, it ends.'", "     +1 Insight"], easterEgg: true },
    ],
    quiz: {
      trigger: { x: 10, y: 3 },
      question: "A headline says the market\nis crashing. You...",
      options: [
        "Sell everything in a panic",
        "Stress-eat and check again",
        "Close the tab. Breathe.",
        "Text your financially\n  illiterate group chat"
      ]
    }
  },
  // Zone 2: The Opinion Forest
  {
    name: "The Opinion Forest",
    bgColor: '#2e2a1a',
    playerStart: { x: 10, y: 13 },
    exitTile: { x: 10, y: 1 },
    introDialogue: [
      "You wander into\nTHE OPINION FOREST.",
      "Everyone here is an expert.\nNone of them manage money\nfor a living.",
      "Buckle up."
    ],
    npcs: [
      { x: 4, y: 10, type: 'coworker', lines: ["My brother-in-law made 400K\non crypto. Put everything in\nBitcoin.", "He also lost 380K of it\nbut we don't talk about\nthat part."] },
      { x: 10, y: 8, type: 'family', lines: ["Your father and I think\nyou should buy a house.\nRenting is throwing money away.", "We bought ours in 1987\nfor $60,000. So basically\nthe same market."] },
      { x: 3, y: 5, type: 'friend', lines: ["Bro. Index funds. That's it.\nAnyone who says otherwise is\ntrying to sell you something.", "I read one book in 2019 and\nnow I'm basically Warren\nBuffett."] },
      { x: 15, y: 4, type: 'coworker', lines: ["Financial advisors are all\ncrooks. Every single one.", "My evidence? A Reddit thread\nand a bad experience with\na guy at a bank in 2014."] },
      { x: 7, y: 7, type: 'friend', lines: ["There's this app that\nbasically replaces a\nfinancial planner. For free!", "It also sold my data to\n47 advertisers but whatever,\nit had a nice UI."] },
      { x: 1, y: 12, type: 'sign', lines: ["Carved into a tree:\n'Opinions are free.\nThat's exactly what\nthey're worth.\n\nOften less.'", "     +1 Insight"], easterEgg: true },
    ],
    quiz: {
      trigger: { x: 10, y: 3 },
      question: "Everyone's giving you\nconflicting money advice.\nYou...",
      options: [
        "Go with whoever's loudest",
        "Nod politely. Do nothing.",
        "Google it at 2am. Spiral.",
        "Wonder if anyone actually\n  knows what they're doing"
      ]
    }
  },
  // Zone 3: The Worry Mountains
  {
    name: "The Worry Mountains",
    bgColor: '#1a1a2e',
    playerStart: { x: 10, y: 13 },
    exitTile: { x: 10, y: 1 },
    introDialogue: [
      "You climb into\nTHE WORRY MOUNTAINS.",
      "It's quiet here.\nNo talking heads. No uncles.\nJust you and your own brain.",
      "Spoiler: your brain is\nnot on your side right now."
    ],
    npcs: [
      { x: 4, y: 9, type: 'thought', lines: ["What if I pick the wrong\nplan and it costs my family\neverything I've worked for?", "Cool. Love this thought\nat 3am. Very productive."] },
      { x: 10, y: 7, type: 'thought', lines: ["My kids are counting on me\nand I'm out here pretending\nI know what a 529 is."] },
      { x: 6, y: 4, type: 'thought', lines: ["Everyone else has it figured\nout. Right? They MUST.\n\n...Right?", "They don't. Nobody does.\nThat's the secret nobody\nposts about."] },
      { x: 9, y: 11, type: 'thought', lines: ["What if I trust the wrong\nperson with my money and\nthey just... take it?", "What if I trust nobody and\njust keep doing nothing?\n\nThat's also a choice.\nA bad one."] },
      { x: 3, y: 6, type: 'thought', lines: ["Am I the only one who feels\ncompletely lost about this?", "No. You're not. Not even\nclose. Most people just\ndon't say it out loud."] },
    ],
    quiz: {
      trigger: { x: 10, y: 3 },
      question: "What actually keeps you up\nat night about money?",
      options: [
        "Running out before I'm done",
        "Something happening to me\n  and nobody has a plan",
        "Making one expensive mistake\n  that ruins everything",
        "Having no idea who to trust"
      ]
    }
  },
  // Zone 4: The Wizard's Tower
  {
    name: "The Iconoclastic Guide",
    bgColor: '#0e0e2a',
    playerStart: { x: 10, y: 13 },
    exitTile: null,
    introDialogue: [
      "A warm light cuts through\nthe noise.",
      "You walked through the panic,\nthe bad takes, and your own\n3am anxiety spirals.",
      "Most people turn back.\nYou didn't. That matters\nmore than you think.",
    ],
    npcs: [
      { x: 4, y: 9, type: 'sign', lines: ["You don't have to figure\nthis out alone.\n\nThat's not brave. It's just\nstubborn."] },
      { x: 10, y: 9, type: 'sign', lines: ["No commissions. No kickbacks.\nNo product sales.\n\nJust someone who actually\ngives a damn about your plan."] },
    ],
    wizard: { x: 10, y: 5 }
  }
];

// ========== CANVAS-DRAWN CHARACTER SYSTEM ==========
// Each character is drawn procedurally — no external assets needed

const CHAR_COLORS = {
  player: { hair: '#4a3728', skin: '#f0c8a0', shirt: '#3a7a5a', pants: '#2a4a6a', shoes: '#2a2a2a' },
  ben: { hair: '#5a4a2a', skin: '#e8c090', shirt: '#4a8a4a', pants: '#3a5a3a', shoes: '#3a2a1a' },
  luna: { hair: '#1a1a3a', skin: '#d4a878', shirt: '#3a5a9a', pants: '#2a2a4a', shoes: '#2a2a3a' },
  max: { hair: '#8a4a2a', skin: '#f0c8a0', shirt: '#aa4a2a', pants: '#3a3a3a', shoes: '#4a2a1a' },
  jordan: { hair: '#3a2a1a', skin: '#c08050', shirt: '#d4853a', pants: '#4a4a5a', shoes: '#2a2a2a' },
  sage: { hair: '#8a8a8a', skin: '#e8d0b0', shirt: '#5a5a7a', pants: '#3a3a4a', shoes: '#3a3a3a' },
  villager: { hair: '#6a5a3a', skin: '#e8c098', shirt: '#6a6a5a', pants: '#4a4a3a', shoes: '#3a2a1a' },
  coworker: { hair: '#3a3a3a', skin: '#f0c8a0', shirt: '#4a5a8a', pants: '#2a2a3a', shoes: '#2a2a2a' },
  reporter: { hair: '#8a3a2a', skin: '#e8b888', shirt: '#8a2a2a', pants: '#3a3a3a', shoes: '#2a2a2a' },
  family: { hair: '#7a7a7a', skin: '#e0b890', shirt: '#6a4a5a', pants: '#4a3a3a', shoes: '#3a2a2a' },
  friend: { hair: '#2a2a2a', skin: '#d4a870', shirt: '#2a6a4a', pants: '#3a3a5a', shoes: '#2a2a2a' },
  wizard: { hair: '#9a9aaa', skin: '#e0c8b0', shirt: '#3a3a8a', pants: '#2a2a5a', shoes: '#3a2a3a', hat: '#4a3a9a', robe: true },
};

const SF = 32; // sprite frame size
const CHAR_SCALE = 2;
const CHAR_SIZE = SF * CHAR_SCALE; // 64px

// Pre-render character sprite sheets to offscreen canvases
const SPRITE_CANVASES = {};

function drawPixelChar(offCtx, x, y, colors, dir, frame, isWalking) {
  const c = colors;
  const bobY = isWalking ? Math.sin(frame * 0.8) * 1.5 : 0;
  const legSwing = isWalking ? Math.sin(frame * 0.8) * 2 : 0;

  // Shadow
  offCtx.fillStyle = 'rgba(0,0,0,0.2)';
  offCtx.beginPath();
  offCtx.ellipse(x + 16, y + 30, 7, 2.5, 0, 0, Math.PI * 2);
  offCtx.fill();

  // Shoes
  offCtx.fillStyle = c.shoes;
  offCtx.fillRect(x + 10 + legSwing, y + 27, 5, 3);
  offCtx.fillRect(x + 17 - legSwing, y + 27, 5, 3);

  // Legs
  offCtx.fillStyle = c.pants;
  offCtx.fillRect(x + 11 + legSwing * 0.5, y + 22 + bobY, 4, 6);
  offCtx.fillRect(x + 17 - legSwing * 0.5, y + 22 + bobY, 4, 6);

  // Body
  offCtx.fillStyle = c.shirt;
  if (c.robe) {
    offCtx.fillRect(x + 8, y + 13 + bobY, 16, 11);
    offCtx.fillRect(x + 7, y + 18 + bobY, 18, 6);
    offCtx.fillStyle = '#d4a030';
    offCtx.fillRect(x + 8, y + 13 + bobY, 16, 1);
    offCtx.fillRect(x + 15, y + 13 + bobY, 2, 11);
  } else {
    offCtx.fillRect(x + 10, y + 14 + bobY, 12, 9);
  }

  // Arms
  offCtx.fillStyle = c.skin;
  if (dir === 2) {
    offCtx.fillRect(x + 8, y + 15 + bobY, 3, 6);
  } else if (dir === 3) {
    offCtx.fillRect(x + 21, y + 15 + bobY, 3, 6);
  } else {
    offCtx.fillRect(x + 8, y + 15 + bobY, 3, 5);
    offCtx.fillRect(x + 21, y + 15 + bobY, 3, 5);
  }

  // Head
  offCtx.fillStyle = c.skin;
  offCtx.fillRect(x + 11, y + 5 + bobY, 10, 10);

  // Hair
  offCtx.fillStyle = c.hair;
  if (c.hat) {
    offCtx.fillStyle = c.hat;
    offCtx.fillRect(x + 9, y + 4 + bobY, 14, 3);
    offCtx.fillRect(x + 12, y + 1 + bobY, 8, 4);
    offCtx.fillRect(x + 14, y - 1 + bobY, 4, 3);
    offCtx.fillRect(x + 7, y + 7 + bobY, 18, 2);
  } else {
    offCtx.fillRect(x + 10, y + 4 + bobY, 12, 4);
    if (dir === 0) {
      offCtx.fillRect(x + 10, y + 5 + bobY, 3, 2);
      offCtx.fillRect(x + 19, y + 5 + bobY, 3, 2);
    } else if (dir === 1) {
      offCtx.fillRect(x + 10, y + 4 + bobY, 12, 5);
    } else {
      offCtx.fillRect(x + (dir === 2 ? 10 : 18), y + 4 + bobY, 4, 6);
    }
  }

  // Eyes
  if (dir !== 1) {
    offCtx.fillStyle = '#1a1a1a';
    if (dir === 0) {
      offCtx.fillRect(x + 13, y + 9 + bobY, 2, 2);
      offCtx.fillRect(x + 17, y + 9 + bobY, 2, 2);
    } else if (dir === 2) {
      offCtx.fillRect(x + 12, y + 9 + bobY, 2, 2);
    } else {
      offCtx.fillRect(x + 18, y + 9 + bobY, 2, 2);
    }
  }

  // Wizard staff
  if (c.robe) {
    offCtx.fillStyle = '#6a4a2a';
    offCtx.fillRect(x + 23, y + 6 + bobY, 2, 18);
    offCtx.fillStyle = '#d4a030';
    offCtx.fillRect(x + 22, y + 4 + bobY, 4, 3);
  }
}

function generateSpriteSheet(type) {
  const offCanvas = document.createElement('canvas');
  offCanvas.width = SF * 4;
  offCanvas.height = SF * 4;
  const offCtx = offCanvas.getContext('2d');
  offCtx.imageSmoothingEnabled = false;

  const colors = CHAR_COLORS[type] || CHAR_COLORS.player;

  // Row 0: Down (4 frames)
  for (let f = 0; f < 4; f++) drawPixelChar(offCtx, f * SF, 0, colors, 0, f * 3, true);
  // Row 1: Up (4 frames)
  for (let f = 0; f < 4; f++) drawPixelChar(offCtx, f * SF, SF, colors, 1, f * 3, true);
  // Row 2: Left (4 frames)
  for (let f = 0; f < 4; f++) drawPixelChar(offCtx, f * SF, SF * 2, colors, 2, f * 3, true);
  // Row 3: Right (4 frames)
  for (let f = 0; f < 4; f++) drawPixelChar(offCtx, f * SF, SF * 3, colors, 3, f * 3, true);

  return offCanvas;
}

function initSpriteSheets() {
  for (const type of Object.keys(CHAR_COLORS)) {
    SPRITE_CANVASES[type] = generateSpriteSheet(type);
  }
}
initSpriteSheets();

const SPRITE_TYPES = new Set(Object.keys(CHAR_COLORS));

const ANIM_MAP = {
  down:  { row: 0, frames: 4 },
  up:    { row: 1, frames: 4 },
  left:  { row: 2, frames: 4 },
  right: { row: 3, frames: 4 },
  idle:  { row: 0, frames: 2 },
};
const DIR_ANIM = ['down', 'up', 'left', 'right'];

function drawCharacterSprite(x, y, type, dir, frame, isMoving) {
  const sheet = SPRITE_CANVASES[type];
  if (!sheet) return;

  const px = x * TILE;
  const py = y * TILE;
  const drawX = px + (TILE - CHAR_SIZE) / 2;
  const drawY = py + TILE - CHAR_SIZE;

  let animKey = isMoving ? (DIR_ANIM[dir] || 'down') : 'idle';
  const anim = ANIM_MAP[animKey];
  const animFrame = Math.floor(frame / 10) % anim.frames;

  const sx = animFrame * SF;
  const sy = anim.row * SF;

  ctx.drawImage(sheet, sx, sy, SF, SF, drawX, drawY, CHAR_SIZE, CHAR_SIZE);
}

function drawPlayerSmooth() {
  const type = selectedArchetype ? selectedArchetype.sprite : 'player';
  const sheet = SPRITE_CANVASES[type];
  if (!sheet) return;

  const px = player.px;
  const py = player.py;
  const drawX = px + (TILE - CHAR_SIZE) / 2;
  const drawY = py + TILE - CHAR_SIZE;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(px + TILE / 2, py + TILE - 2, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  let animKey;
  if (!player.isMoving && !player.moving) {
    animKey = 'idle';
  } else {
    animKey = DIR_ANIM[player.dir] || 'down';
  }

  const anim = ANIM_MAP[animKey];
  const animFrame = Math.floor(player.frame / 4) % anim.frames;

  const sx = animFrame * SF;
  const sy = anim.row * SF;

  ctx.drawImage(sheet, sx, sy, SF, SF, drawX, drawY, CHAR_SIZE, CHAR_SIZE);
}

// ========== PIXEL ART SPRITE DRAWING (objects only) ==========
function drawSprite(x, y, type, dir, frame) {
  // Character types use real sprite sheets
  if (SPRITE_TYPES.has(type)) {
    const isMoving = (type === 'player') ? player.moving : false;
    drawCharacterSprite(x, y, type, dir, frame, isMoving);
    return;
  }

  // Non-character objects use pixel art
  const px = x * TILE;
  const py = y * TILE;

  if (type === 'tv') {
    ctx.fillStyle = '#3a3a4a';
    ctx.fillRect(px + 4, py + 4, 24, 20);
    ctx.fillStyle = (frameCount % 30 < 15) ? '#ff4444' : '#ff8844';
    ctx.fillRect(px + 6, py + 6, 20, 16);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    for (let i = 0; i < 4; i++) {
      ctx.fillRect(px + 6, py + 6 + i * 4 + (frameCount % 3), 20, 2);
    }
    ctx.fillStyle = '#3a3a4a';
    ctx.fillRect(px + 12, py + 24, 8, 4);
    ctx.fillRect(px + 10, py, 2, 6);
    ctx.fillRect(px + 20, py, 2, 6);
    ctx.fillStyle = PAL.red;
    ctx.font = '12px "Press Start 2P"';
    ctx.fillText('!', px + 14, py);
  }
  else if (type === 'thought') {
    const bob = Math.sin(frameCount * 0.05 + x + y) * 4;
    ctx.fillStyle = 'rgba(180,180,220,0.6)';
    ctx.beginPath();
    ctx.arc(px + 16, py + 12 + bob, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(140,140,180,0.8)';
    ctx.beginPath();
    ctx.arc(px + 16, py + 12 + bob, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = PAL.white;
    ctx.fillRect(px + 10, py + 12 + bob, 2, 2);
    ctx.fillRect(px + 16, py + 12 + bob, 2, 2);
    ctx.fillRect(px + 22, py + 12 + bob, 2, 2);
  }
  else if (type === 'sign') {
    ctx.fillStyle = PAL.brown;
    ctx.fillRect(px + 14, py + 16, 4, 14);
    ctx.fillStyle = PAL.accent;
    ctx.fillRect(px + 4, py + 6, 24, 12);
    ctx.fillStyle = PAL.dark;
    ctx.fillRect(px + 6, py + 8, 20, 8);
    ctx.fillStyle = PAL.white;
    ctx.fillRect(px + 10, py + 10, 2, 2);
    ctx.fillRect(px + 14, py + 10, 2, 2);
    ctx.fillRect(px + 18, py + 10, 2, 2);
  }
}

// ========== MAP DRAWING ==========
function drawZoneBackground(zone) {
  const z = ZONES[zone];

  if (zone === 0) {
    // Uncertainville - small village
    ctx.fillStyle = '#2a3a2a';
    ctx.fillRect(0, 0, W, H);
    // Grass variation
    for (let x = 0; x < COLS; x++) {
      for (let y = 0; y < ROWS; y++) {
        const hash = (x * 7 + y * 13) % 5;
        ctx.fillStyle = hash === 0 ? '#2e4e2e' : hash === 1 ? '#264226' : '#2a3a2a';
        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
      }
    }
    // Path (vertical road - centered)
    for (let y = 0; y < ROWS; y++) {
      ctx.fillStyle = '#5a5040';
      ctx.fillRect(9 * TILE, y * TILE, 3 * TILE, TILE);
      ctx.fillStyle = '#4a4030';
      ctx.fillRect(9 * TILE + 2, y * TILE + 6, TILE - 4, 2);
    }
    // Houses
    drawHouse(2, 7);
    drawHouse(15, 9);
    drawHouse(2, 11);
    // Trees
    drawTree(0, 2); drawTree(17, 3); drawTree(0, 5);
    drawTree(16, 6); drawTree(18, 1); drawTree(1, 0);
    drawTree(17, 0); drawTree(19, 0); drawTree(15, 2);
    // Exit indicator
    drawExitArrow(10, 0);
  }
  else if (zone === 1) {
    // Media Swamp
    ctx.fillStyle = '#1a2a1a';
    ctx.fillRect(0, 0, W, H);
    for (let x = 0; x < COLS; x++) {
      for (let y = 0; y < ROWS; y++) {
        const hash = (x * 11 + y * 7 + frameCount * 0.01) % 4;
        ctx.fillStyle = hash < 1 ? '#1e2e1a' : hash < 2 ? '#1a2a18' : '#1c2c1c';
        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
        // Swamp bubbles
        if ((x * 3 + y * 17) % 23 === 0 && frameCount % 60 < 10) {
          ctx.fillStyle = 'rgba(100,150,100,0.3)';
          ctx.beginPath();
          ctx.arc(x * TILE + 16, y * TILE + 16, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    // Path
    for (let y = 0; y < ROWS; y++) {
      ctx.fillStyle = '#3a3a30';
      ctx.fillRect(9 * TILE, y * TILE, 3 * TILE, TILE);
    }
    // Cables/wires
    ctx.strokeStyle = '#4a4a4a';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(0, 60 + i * 100);
      ctx.lineTo(W, 80 + i * 100);
      ctx.stroke();
    }
    drawExitArrow(10, 0);
  }
  else if (zone === 2) {
    // Opinion Forest
    ctx.fillStyle = '#2a2a1a';
    ctx.fillRect(0, 0, W, H);
    for (let x = 0; x < COLS; x++) {
      for (let y = 0; y < ROWS; y++) {
        const hash = (x * 13 + y * 9) % 4;
        ctx.fillStyle = hash === 0 ? '#2e2e1e' : hash === 1 ? '#262618' : '#2a2a1a';
        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
      }
    }
    // Path
    for (let y = 0; y < ROWS; y++) {
      ctx.fillStyle = '#4a4030';
      ctx.fillRect(9 * TILE, y * TILE, 3 * TILE, TILE);
    }
    // Dense trees
    drawTree(0, 1); drawTree(1, 3); drawTree(0, 6); drawTree(1, 9);
    drawTree(0, 12); drawTree(16, 0); drawTree(17, 2); drawTree(18, 5);
    drawTree(16, 8); drawTree(17, 11); drawTree(18, 13);
    drawTree(2, 0); drawTree(16, 13);
    drawExitArrow(10, 0);
  }
  else if (zone === 3) {
    // Worry Mountains
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, W, H);
    for (let x = 0; x < COLS; x++) {
      for (let y = 0; y < ROWS; y++) {
        const hash = (x * 5 + y * 11) % 5;
        ctx.fillStyle = hash < 2 ? '#1e1e32' : hash < 4 ? '#1a1a2e' : '#22223a';
        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
      }
    }
    // Mountain peaks in background
    ctx.fillStyle = '#2a2a4a';
    for (let i = 0; i < 5; i++) {
      const mx = i * 110 + 20;
      ctx.beginPath();
      ctx.moveTo(mx - 50, 160);
      ctx.lineTo(mx, 20 + i * 10);
      ctx.lineTo(mx + 50, 160);
      ctx.fill();
    }
    // Snow caps
    ctx.fillStyle = '#8888aa';
    for (let i = 0; i < 5; i++) {
      const mx = i * 110 + 20;
      ctx.beginPath();
      ctx.moveTo(mx - 16, 50 + i * 10);
      ctx.lineTo(mx, 20 + i * 10);
      ctx.lineTo(mx + 16, 50 + i * 10);
      ctx.fill();
    }
    // Path
    for (let y = 5; y < ROWS; y++) {
      ctx.fillStyle = '#3a3a50';
      ctx.fillRect(9 * TILE, y * TILE, 3 * TILE, TILE);
    }
    drawExitArrow(10, 0);
  }
  else if (zone === 4) {
    // Wizard's Tower (centered in 20-col grid)
    ctx.fillStyle = '#0e0e2a';
    ctx.fillRect(0, 0, W, H);
    // Starfield
    for (let i = 0; i < 40; i++) {
      const sx = (i * 37 + frameCount * 0.1) % W;
      const sy = (i * 53) % H;
      const brightness = Math.sin(frameCount * 0.02 + i) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255,255,255,${brightness * 0.6})`;
      ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
    }
    // Tower base
    ctx.fillStyle = '#2a2a5a';
    ctx.fillRect(7 * TILE, 2 * TILE, 7 * TILE, 8 * TILE);
    ctx.fillStyle = '#22224a';
    ctx.fillRect(8 * TILE, 1 * TILE, 5 * TILE, 1 * TILE);
    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(9 * TILE, 0, 3 * TILE, 1 * TILE);
    // Door
    ctx.fillStyle = '#4a3a2a';
    ctx.fillRect(9 * TILE + 8, 9 * TILE, 2 * TILE + 16, 1 * TILE);
    // Windows with warm light
    const glowAlpha = Math.sin(frameCount * 0.03) * 0.15 + 0.6;
    ctx.fillStyle = `rgba(244, 208, 63, ${glowAlpha})`;
    ctx.fillRect(8 * TILE + 8, 4 * TILE, 16, 16);
    ctx.fillRect(12 * TILE + 8, 4 * TILE, 16, 16);
    ctx.fillRect(10 * TILE + 4, 3 * TILE, 20, 16);
    // Warm light path
    ctx.fillStyle = `rgba(244, 208, 63, 0.05)`;
    for (let y = 10; y < ROWS; y++) {
      ctx.fillRect(8 * TILE, y * TILE, 5 * TILE, TILE);
    }
    // Ground path
    ctx.fillStyle = '#2a2a3a';
    for (let y = 10; y < ROWS; y++) {
      ctx.fillRect(9 * TILE, y * TILE, 3 * TILE, TILE);
    }
  }
}

function drawHouse(x, y) {
  ctx.fillStyle = '#6a5a4a';
  ctx.fillRect(x * TILE, y * TILE, 2 * TILE, 2 * TILE);
  ctx.fillStyle = '#8a3a2a';
  ctx.fillRect(x * TILE - 4, (y - 1) * TILE + 16, 2 * TILE + 8, TILE);
  // Door
  ctx.fillStyle = '#4a3a2a';
  ctx.fillRect(x * TILE + 10, y * TILE + TILE, 12, TILE);
  // Window
  ctx.fillStyle = PAL.accent;
  ctx.fillRect(x * TILE + TILE + 8, y * TILE + 8, 12, 10);
}

function drawTree(x, y) {
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(x * TILE + 12, y * TILE + 18, 8, 12);
  ctx.fillStyle = '#2a5a2a';
  ctx.fillRect(x * TILE + 4, y * TILE + 4, 24, 16);
  ctx.fillStyle = '#3a6a3a';
  ctx.fillRect(x * TILE + 8, y * TILE, 16, 12);
}

function drawExitArrow(x, y) {
  const blink = frameCount % 40 < 25;
  if (blink) {
    ctx.fillStyle = PAL.accent;
    ctx.fillRect(x * TILE + 10, y * TILE + 4, 12, 4);
    ctx.fillRect(x * TILE + 12, y * TILE, 8, 4);
    ctx.fillRect(x * TILE + 14, y * TILE - 2, 4, 2);
  }
}

// ========== COLLISION ==========
function isWalkable(x, y) {
  if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
  // Check NPCs
  for (const npc of npcs) {
    if (npc.x === x && npc.y === y) return false;
  }
  // Zone-specific walls
  if (currentZone === 0) {
    // Houses block (spread wider)
    if ((x >= 2 && x <= 3 && y >= 7 && y <= 8) ||
        (x >= 15 && x <= 16 && y >= 9 && y <= 10) ||
        (x >= 2 && x <= 3 && y >= 11 && y <= 12)) return false;
    // Trees block
    const trees = [[0,2],[1,0],[17,3],[0,5],[16,6],[18,1],[0,0],[19,0],[17,0],[15,2]];
    for (const t of trees) { if (t[0] === x && t[1] === y) return false; }
  }
  else if (currentZone === 2) {
    const trees = [[0,1],[1,3],[0,6],[1,9],[0,12],[16,0],[17,2],[18,5],[16,8],[17,11],[18,13],[2,0],[16,13]];
    for (const t of trees) { if (t[0] === x && t[1] === y) return false; }
  }
  else if (currentZone === 4) {
    // Tower occupies x:7-13, y:2-9
    const inTowerBounds = (x >= 7 && x <= 13 && y >= 2 && y <= 9);
    if (inTowerBounds) {
      // Door opening
      if (x >= 9 && x <= 11 && y === 9) return true;
      // Interior is walkable
      if (x >= 8 && x <= 12 && y >= 3 && y <= 8) {
        const wiz = ZONES[4].wizard;
        if (wiz && x === wiz.x && y === wiz.y) return false;
        return true;
      }
      return false;
    }
  }
  return true;
}

// ========== TEXT WRAPPING UTILITY ==========
function wrapText(text, maxWidth, fontSize) {
  ctx.font = `${fontSize}px "Press Start 2P"`;
  const words = text.split(' ');
  const lines = [];
  let currentLine = '';

  for (const word of words) {
    // Handle explicit newlines
    const parts = word.split('\n');
    for (let p = 0; p < parts.length; p++) {
      if (p > 0) {
        lines.push(currentLine);
        currentLine = '';
      }
      const testLine = currentLine ? currentLine + ' ' + parts[p] : parts[p];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = parts[p];
      } else {
        currentLine = testLine;
      }
    }
  }
  if (currentLine) lines.push(currentLine);
  return lines;
}

// ========== DIALOGUE SYSTEM ==========
function showDialogue(lines) {
  dialogueQueue = [...lines];
  advanceDialogue();
}

function advanceDialogue() {
  if (currentDialogue && dialogueCharIndex < currentDialogue.length) {
    dialogueCharIndex = currentDialogue.length;
    return;
  }
  if (dialogueQueue.length > 0) {
    currentDialogue = dialogueQueue.shift();
    dialogueCharIndex = 0;
    dialogueTimer = 0;
    gameState = 'dialogue';
  } else {
    currentDialogue = null;
    // During wizard interaction, stay in dialogue state so interact() can advance phases
    if (currentZone === 4 && wizardPhase > 0 && wizardPhase < 5) {
      gameState = 'dialogue';
    } else {
      gameState = 'playing';
    }
  }
}

// Track which NPC triggered the current dialogue for portrait display
let dialogueNpcType = null;

function drawDialogueBox() {
  if (!currentDialogue) {
    // In wizard flow, show a continue prompt
    if (currentZone === 4 && wizardPhase > 0 && wizardPhase < 5 && gameState === 'dialogue') {
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      ctx.fillRect(8, H - 120, W - 16, 112);
      ctx.strokeStyle = PAL.wizardGold;
      ctx.lineWidth = 2;
      ctx.strokeRect(10, H - 118, W - 20, 108);
      ctx.fillStyle = PAL.lightGray;
      ctx.font = '11px "Press Start 2P"';
      ctx.fillText('...', 24, H - 70);
      const blink = frameCount % 30 < 20;
      if (blink) {
        ctx.fillStyle = PAL.accent;
        ctx.fillRect(W - 36, H - 20, 10, 10);
      }
    }
    return;
  }

  // Determine dialogue style based on NPC type
  const isWizard = currentZone === 4 && wizardPhase > 0;
  const isTV = dialogueNpcType === 'tv';
  const isThought = dialogueNpcType === 'thought';

  // Box background
  if (isTV) {
    // Broadcast style - dark with red scan lines
    ctx.fillStyle = 'rgba(15,0,0,0.93)';
    ctx.fillRect(8, H - 120, W - 16, 112);
    ctx.strokeStyle = '#cc3333';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, H - 118, W - 20, 108);
    // Scan line effect
    ctx.fillStyle = 'rgba(255,0,0,0.05)';
    for (let sy = H - 118; sy < H - 10; sy += 4) {
      ctx.fillRect(10, sy, W - 20, 2);
    }
  } else if (isThought) {
    // Thought bubble style - translucent, soft
    ctx.fillStyle = 'rgba(20,20,40,0.85)';
    ctx.fillRect(8, H - 120, W - 16, 112);
    ctx.strokeStyle = 'rgba(150,150,200,0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, H - 118, W - 20, 108);
    // Soft inner glow
    ctx.fillStyle = 'rgba(100,100,160,0.06)';
    ctx.fillRect(12, H - 116, W - 24, 104);
  } else {
    // Standard box
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.fillRect(8, H - 120, W - 16, 112);
    ctx.strokeStyle = isWizard ? PAL.wizardGold : PAL.white;
    ctx.lineWidth = 2;
    ctx.strokeRect(10, H - 118, W - 20, 108);
  }

  // Portrait area for character NPCs
  let textOffset = 24;
  if (isWizard) {
    const wizSheet = SPRITE_CANVASES['wizard'];
    if (wizSheet) {
      ctx.strokeStyle = PAL.wizardGold;
      ctx.strokeRect(10, H - 118, 52, 52);
      ctx.drawImage(wizSheet, 0, 0, SF, SF, 12, H - 116, 48, 48);
      textOffset = 70;
    }
    ctx.strokeStyle = PAL.wizardGold;
    ctx.lineWidth = 2;
    ctx.strokeRect(10, H - 118, W - 20, 108);
  } else if (dialogueNpcType && SPRITE_TYPES.has(dialogueNpcType)) {
    // Show NPC portrait from canvas-drawn sprite
    const npcSheet = SPRITE_CANVASES[dialogueNpcType];
    if (npcSheet) {
      // Dark portrait background
      ctx.fillStyle = 'rgba(20,20,30,0.8)';
      ctx.fillRect(12, H - 116, 48, 48);
      ctx.strokeStyle = PAL.lightGray;
      ctx.lineWidth = 1;
      ctx.strokeRect(12, H - 116, 48, 48);
      ctx.drawImage(npcSheet, 0, 0, SF, SF, 14, H - 114, 44, 44);
      textOffset = 70;
    }
  } else if (isTV) {
    // TV icon
    ctx.fillStyle = '#333';
    ctx.fillRect(14, H - 112, 40, 32);
    ctx.fillStyle = '#ff4444';
    ctx.fillRect(16, H - 110, 36, 28);
    ctx.fillStyle = '#ff6666';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('LIVE', 18, H - 90);
    ctx.fillStyle = '#333';
    ctx.fillRect(28, H - 78, 12, 6);
    textOffset = 62;
  } else if (isThought) {
    // Thought icon - small floating thought bubbles
    ctx.fillStyle = 'rgba(150,150,200,0.4)';
    ctx.beginPath();
    ctx.arc(34, H - 96, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(130,130,180,0.5)';
    ctx.beginPath();
    ctx.arc(34, H - 96, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = PAL.white;
    ctx.fillRect(28, H - 98, 2, 2);
    ctx.fillRect(34, H - 98, 2, 2);
    ctx.fillRect(40, H - 98, 2, 2);
    textOffset = 56;
  }

  // Text with auto-wrapping
  const shown = currentDialogue.substring(0, dialogueCharIndex);
  const textColor = isTV ? '#ff9999' : isThought ? 'rgba(180,180,220,0.9)' : PAL.white;
  ctx.fillStyle = textColor;
  const fontSize = 11;
  const maxTextWidth = W - textOffset - 28;
  const wrappedLines = wrapText(shown, maxTextWidth, fontSize);
  const lineHeight = 20;
  const maxLines = 4;
  // Show last N lines if overflow
  const startLine = Math.max(0, wrappedLines.length - maxLines);
  for (let i = startLine; i < wrappedLines.length; i++) {
    ctx.fillText(wrappedLines[i], textOffset, H - 98 + (i - startLine) * lineHeight);
  }

  // Advance indicator
  if (dialogueCharIndex >= currentDialogue.length) {
    const blink = frameCount % 30 < 20;
    if (blink) {
      ctx.fillStyle = isTV ? '#ff4444' : PAL.accent;
      ctx.fillRect(W - 36, H - 20, 10, 10);
    }
  }

  // Auto-advance text
  dialogueTimer++;
  if (dialogueTimer % 2 === 0 && dialogueCharIndex < currentDialogue.length) {
    dialogueCharIndex++;
  }
}

// ========== QUIZ SYSTEM ==========
function showQuiz(quiz) {
  quizData = quiz;
  quizSelection = 0;
  gameState = 'quiz';
}

function drawQuiz() {
  const qd = (currentZone === 4 && wizardQuizData) ? wizardQuizData : quizData;
  if (!qd) return;

  // Overlay
  ctx.fillStyle = 'rgba(0,0,0,0.92)';
  ctx.fillRect(0, 0, W, H);

  // Question
  ctx.fillStyle = PAL.accent;
  ctx.font = '13px "Press Start 2P"';
  const qLines = qd.question.split('\n');
  for (let i = 0; i < qLines.length; i++) {
    ctx.fillText(qLines[i], 24, 60 + i * 24);
  }

  // Options
  const startY = 140;
  for (let i = 0; i < qd.options.length; i++) {
    const selected = i === quizSelection;
    ctx.fillStyle = selected ? PAL.accent : PAL.gray;
    ctx.font = '11px "Press Start 2P"';
    const prefix = selected ? '► ' : '  ';
    ctx.fillText(prefix + qd.options[i], 24, startY + i * 52);

    if (selected) {
      ctx.fillStyle = 'rgba(226,183,20,0.1)';
      ctx.fillRect(16, startY + i * 52 - 16, W - 32, 30);
    }
  }

  // Instructions
  ctx.fillStyle = PAL.lightGray;
  ctx.font = '10px "Press Start 2P"';
  ctx.fillText('↑↓ choose  SPACE select', 16, H - 24);

  // Wrong answer message overlay
  if (quizWrongMsg && quizWrongTimer > 0) {
    ctx.fillStyle = 'rgba(139,58,58,0.92)';
    ctx.fillRect(20, H / 2 - 30, W - 40, 60);
    ctx.strokeStyle = '#ff6666';
    ctx.lineWidth = 2;
    ctx.strokeRect(22, H / 2 - 28, W - 44, 56);
    ctx.fillStyle = '#ffaaaa';
    ctx.font = '10px "Press Start 2P"';
    const wLines = quizWrongMsg.split('\n');
    for (let i = 0; i < wLines.length; i++) {
      ctx.fillText(wLines[i], 36, H / 2 - 6 + i * 18);
    }
  }

  // Minigame wrong answer message
  if (minigameWrongMsg && minigameWrongTimer > 0) {
    ctx.fillStyle = 'rgba(139,58,58,0.92)';
    ctx.fillRect(20, H / 2 - 30, W - 40, 60);
    ctx.strokeStyle = '#ff6666';
    ctx.lineWidth = 2;
    ctx.strokeRect(22, H / 2 - 28, W - 44, 56);
    ctx.fillStyle = '#ffaaaa';
    ctx.font = '11px "Press Start 2P"';
    ctx.fillText(minigameWrongMsg, 36, H / 2 + 4);
  }
}

function selectQuizAnswer() {
  quizAnswers.push({
    question: quizData.question,
    answer: quizData.options[quizSelection],
    index: quizSelection
  });
  quizData = null;
  gameState = 'playing';
  playSfxQuizConfirm();
  // Transition to next zone
  startTransition(() => {
    currentZone++;
    setupZone();
  });
}

// ========== TRANSITIONS ==========
function startTransition(callback) {
  transitionAlpha = 0;
  transitionDir = 1; // fade out
  transitionCallback = callback;
  chapterCardTimer = 0;
  gameState = 'transition';
  playSfxTransition();
  stopMusic();
}

function updateTransition() {
  if (transitionDir === 1) {
    // Phase 1: Fade to black
    transitionAlpha += 0.04;
    if (transitionAlpha >= 1) {
      transitionAlpha = 1;
      if (transitionCallback) transitionCallback();
      transitionDir = 2; // hold for chapter card
      chapterCardTimer = 0;
      // Play zone stinger when card appears
      playZoneStinger(currentZone);
    }
  } else if (transitionDir === 2) {
    // Phase 2: Chapter title card hold
    chapterCardTimer++;
    if (chapterCardTimer >= CHAPTER_CARD_DURATION) {
      transitionDir = 3; // fade in
    }
  } else if (transitionDir === 3) {
    // Phase 3: Fade in
    transitionAlpha -= 0.04;
    if (transitionAlpha <= 0) {
      transitionAlpha = 0;
      transitionDir = 0;
      gameState = 'playing';
      startZoneMusic(currentZone);
      // Show intro dialogue for new zone
      const z = ZONES[currentZone];
      if (z.introDialogue) {
        dialogueNpcType = null;
        showDialogue(z.introDialogue);
      }
    }
  }
}

function drawTransition() {
  ctx.fillStyle = `rgba(0,0,0,${transitionAlpha})`;
  ctx.fillRect(0, 0, W, H);

  // Chapter title card (shown during hold phase)
  if (transitionDir === 2 || (transitionDir === 3 && transitionAlpha > 0.5)) {
    const cardAlpha = transitionDir === 2
      ? Math.min(1, chapterCardTimer / 15) // fade in over 15 frames
      : transitionAlpha * 2 - 1; // fade out with transition

    if (cardAlpha > 0) {
      ctx.globalAlpha = cardAlpha;
      ctx.textAlign = 'center';

      // Chapter number
      ctx.fillStyle = PAL.wizardGold;
      ctx.font = '10px "Press Start 2P"';
      ctx.fillText(`— Chapter ${currentZone + 1} of 5 —`, W / 2, H / 2 - 50);

      // Zone name (large)
      ctx.fillStyle = PAL.white;
      ctx.font = '18px "Press Start 2P"';
      ctx.fillText(ZONES[currentZone].name, W / 2, H / 2);

      // Tagline (italic feel via lighter color + smaller font)
      ctx.fillStyle = PAL.lightGray;
      ctx.font = '10px "Press Start 2P"';
      const tagline = ZONE_TAGLINES[currentZone] || '';
      ctx.fillText(tagline, W / 2, H / 2 + 36);

      // Decorative line
      ctx.fillStyle = `rgba(244, 208, 63, ${cardAlpha * 0.4})`;
      ctx.fillRect(W / 2 - 80, H / 2 + 52, 160, 2);

      ctx.textAlign = 'left';
      ctx.globalAlpha = 1;
    }
  }
}

// ========== INTRO SEQUENCE ==========
function drawIntro() {
  introTimer++;
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, W, H);

  const phase1End = 40;  // fade in
  const phase2End = 140; // hold
  const phase3End = INTRO_DURATION; // fade out

  let alpha = 0;
  if (introTimer < phase1End) {
    alpha = introTimer / phase1End;
  } else if (introTimer < phase2End) {
    alpha = 1;
  } else if (introTimer < phase3End) {
    alpha = 1 - (introTimer - phase2End) / (phase3End - phase2End);
  }

  ctx.globalAlpha = alpha;
  ctx.textAlign = 'center';

  // Subtle line accent
  const lineW = 120 + Math.sin(introTimer * 0.03) * 10;
  ctx.fillStyle = PAL.wizardGold;
  ctx.fillRect(W / 2 - lineW / 2, 205, lineW, 2);

  // Company wordmark
  ctx.fillStyle = PAL.white;
  ctx.font = '13px "Press Start 2P"';
  ctx.fillText('ICONOCLASTIC', W / 2, 236);
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '10px "Press Start 2P"';
  ctx.fillText('C A P I T A L', W / 2, 258);

  // Tagline
  ctx.fillStyle = PAL.gray;
  ctx.font = '8px "Press Start 2P"';
  ctx.fillText('presents', W / 2, 290);

  // Subtle sparkle particles during hold
  if (introTimer > phase1End && introTimer < phase2End) {
    for (let i = 0; i < 6; i++) {
      const sparkleAlpha = Math.sin(introTimer * 0.1 + i * 1.5) * 0.4 + 0.3;
      const sx = W / 2 + Math.cos(introTimer * 0.02 + i * Math.PI / 3) * (80 + i * 15);
      const sy = 240 + Math.sin(introTimer * 0.025 + i * Math.PI / 3) * 40;
      ctx.fillStyle = `rgba(244, 208, 63, ${sparkleAlpha * alpha})`;
      ctx.fillRect(sx - 1, sy - 1, 2, 2);
    }
  }

  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // Auto-advance to title
  if (introTimer >= INTRO_DURATION) {
    gameState = 'title';
    // Play a subtle arrival chime
    if (audioCtx) {
      playNote(440, 0.15, 'triangle', 0.04);
      playNote(554, 0.15, 'triangle', 0.04, 0.12);
      playNote(660, 0.2, 'triangle', 0.04, 0.24);
    }
  }
}

// ========== FEAR BOSS VISUAL ENGINE ==========
function drawFearEntity(cx, cy, health) {
  const shake = fearShake > 0 ? (Math.random() - 0.5) * fearShake : 0;
  const shakeY = fearShake > 0 ? (Math.random() - 0.5) * fearShake : 0;
  const bx = cx + shake;
  const by = cy + shakeY;

  // Base size scales with health
  const baseRadius = 35 + health * 10;
  const pulse = Math.sin(frameCount * 0.06) * 3 * health;

  // Outer aura - dark red, unstable
  const auraAlpha = 0.15 + health * 0.15;
  ctx.fillStyle = `rgba(100, 20, 20, ${auraAlpha})`;
  ctx.beginPath();
  ctx.arc(bx, by + pulse, baseRadius + 20, 0, Math.PI * 2);
  ctx.fill();

  // Distortion ring
  ctx.strokeStyle = `rgba(180, 40, 40, ${health * 0.3})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let a = 0; a < Math.PI * 2; a += 0.1) {
    const distort = Math.sin(a * 5 + frameCount * 0.08) * 4 * health;
    const r = baseRadius + 12 + distort;
    const dx = bx + Math.cos(a) * r;
    const dy = by + pulse + Math.sin(a) * r;
    if (a === 0) ctx.moveTo(dx, dy);
    else ctx.lineTo(dx, dy);
  }
  ctx.closePath();
  ctx.stroke();

  // Core body - dark shifting mass
  const gradient = ctx.createRadialGradient(bx, by + pulse, 0, bx, by + pulse, baseRadius);
  gradient.addColorStop(0, `rgba(60, 10, 10, 0.95)`);
  gradient.addColorStop(0.5, `rgba(120, 25, 25, 0.8)`);
  gradient.addColorStop(1, `rgba(80, 15, 15, 0)`);
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(bx, by + pulse, baseRadius, 0, Math.PI * 2);
  ctx.fill();

  // Draw cracks (appear when taking damage)
  ctx.strokeStyle = `rgba(255, 150, 50, 0.8)`;
  ctx.lineWidth = 1.5;
  for (const crack of fearCracks) {
    ctx.beginPath();
    const startX = bx + crack.x;
    const startY = by + pulse + crack.y;
    ctx.moveTo(startX, startY);
    let endX = startX + Math.cos(crack.angle) * crack.len;
    let endY = startY + Math.sin(crack.angle) * crack.len;
    ctx.lineTo(endX, endY);
    // Branches
    for (let b = 0; b < crack.branches; b++) {
      const branchAngle = crack.angle + (Math.random() - 0.5) * 1.2;
      const branchLen = crack.len * 0.4;
      const midX = startX + Math.cos(crack.angle) * crack.len * (0.3 + b * 0.3);
      const midY = startY + Math.sin(crack.angle) * crack.len * (0.3 + b * 0.3);
      ctx.moveTo(midX, midY);
      ctx.lineTo(midX + Math.cos(branchAngle) * branchLen, midY + Math.sin(branchAngle) * branchLen);
    }
    ctx.stroke();
    // Glow from cracks
    ctx.fillStyle = `rgba(255, 180, 60, 0.15)`;
    ctx.beginPath();
    ctx.arc(endX, endY, 6, 0, Math.PI * 2);
    ctx.fill();
  }

  // Eyes - multiple, staring, blinking
  for (const eye of fearEyes) {
    eye.blinkTimer--;
    if (eye.blinkTimer <= 0) eye.blinkTimer = 120 + Math.random() * 180;
    const isBlinking = eye.blinkTimer < 6;
    const eyeX = bx + eye.x * (0.5 + health * 0.5);
    const eyeY = by + pulse + eye.y * (0.5 + health * 0.5);
    const eyeSize = eye.size * (0.3 + health * 0.7);

    if (!isBlinking && health > 0.1) {
      // White of eye
      ctx.fillStyle = `rgba(200, 180, 180, ${0.6 + health * 0.4})`;
      ctx.beginPath();
      ctx.ellipse(eyeX, eyeY, eyeSize, eyeSize * 0.65, 0, 0, Math.PI * 2);
      ctx.fill();
      // Iris - looks toward player cursor / center
      const lookX = Math.sin(frameCount * 0.02 + eye.x) * 2;
      const lookY = Math.cos(frameCount * 0.03 + eye.y) * 1.5;
      ctx.fillStyle = '#cc2222';
      ctx.beginPath();
      ctx.arc(eyeX + lookX, eyeY + lookY, eyeSize * 0.4, 0, Math.PI * 2);
      ctx.fill();
      // Pupil
      ctx.fillStyle = '#1a0000';
      ctx.beginPath();
      ctx.arc(eyeX + lookX, eyeY + lookY, eyeSize * 0.2, 0, Math.PI * 2);
      ctx.fill();
      // Glint
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillRect(eyeX + lookX - 1, eyeY + lookY - eyeSize * 0.25, 2, 2);
    }
  }

  // "FEAR" text - distorted, glitching
  ctx.textAlign = 'center';
  const textAlpha = 0.6 + health * 0.4;
  const glitchOffset = health < 0.5 ? (Math.random() - 0.5) * 6 : 0;
  ctx.fillStyle = `rgba(255, 80, 80, ${textAlpha})`;
  ctx.font = `${16 + health * 8}px "Press Start 2P"`;
  ctx.fillText('FEAR', bx + glitchOffset, by + pulse + baseRadius + 20);

  // Glitch echo when damaged
  if (health < 0.7) {
    ctx.fillStyle = `rgba(255, 40, 40, ${(1 - health) * 0.2})`;
    ctx.fillText('FEAR', bx - glitchOffset * 2, by + pulse + baseRadius + 20);
  }
  ctx.textAlign = 'left';

  // Decay fear shake
  if (fearShake > 0) fearShake *= 0.92;
}

// ========== STATS RECAP SCREEN ==========
let statsTimer = 0;
function drawStatsScreen() {
  statsTimer++;
  ctx.fillStyle = 'rgba(10,10,26,0.97)';
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 30; i++) {
    const sx = (i * 37 + Math.sin(frameCount * 0.01 + i) * 10) % W;
    const sy = (i * 53 + Math.cos(frameCount * 0.01 + i) * 6) % H;
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(frameCount * 0.03 + i) * 0.3 + 0.4})`;
    ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
  }

  const fadeIn = Math.min(1, statsTimer / 30);
  ctx.globalAlpha = fadeIn;
  ctx.textAlign = 'center';

  // Header
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '14px "Press Start 2P"';
  ctx.fillText('JOURNEY COMPLETE', W / 2, 60);

  // Decorative line
  ctx.fillStyle = PAL.wizardGold;
  ctx.fillRect(W / 2 - 80, 75, 160, 2);

  // Stats with staggered reveal
  const stats = [];
  const elapsed = gameStartTime > 0 ? Math.floor((Date.now() - gameStartTime) / 1000) : 0;
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  stats.push({ label: 'TIME', value: `${minutes}:${seconds.toString().padStart(2, '0')}`, color: PAL.white });
  stats.push({ label: 'ZONES CLEARED', value: '5 / 5', color: PAL.white });
  stats.push({ label: 'STEPS TAKEN', value: `${totalSteps}`, color: PAL.white });
  stats.push({ label: 'NPCs MET', value: `${npcsEncountered}`, color: PAL.white });
  stats.push({ label: 'INSIGHTS FOUND', value: `${insightCount} / 3`, color: insightCount >= 3 ? PAL.wizardGold : PAL.white });
  stats.push({ label: 'FEAR DEFEATED', value: '✓', color: '#66cc66' });
  if (selectedArchetype) {
    stats.push({ label: 'ARCHETYPE', value: selectedArchetype.title, color: selectedArchetype.color });
  }

  const startY = 110;
  for (let i = 0; i < stats.length; i++) {
    const revealFrame = i * 12;
    if (statsTimer < revealFrame) continue;
    const itemAlpha = Math.min(1, (statsTimer - revealFrame) / 15);
    ctx.globalAlpha = fadeIn * itemAlpha;

    const y = startY + i * 42;
    // Label
    ctx.fillStyle = PAL.gray;
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText(stats[i].label, W / 2, y);
    // Value
    ctx.fillStyle = stats[i].color;
    ctx.font = '13px "Press Start 2P"';
    ctx.fillText(stats[i].value, W / 2, y + 22);

    // Play a tick sound on reveal frame
    if (statsTimer === revealFrame + 1) {
      playNote(300 + i * 60, 0.06, 'square', 0.04);
    }
  }

  // Continue prompt
  if (statsTimer > stats.length * 12 + 30) {
    const promptAlpha = Math.sin(frameCount * 0.04) * 0.3 + 0.7;
    ctx.globalAlpha = promptAlpha;
    ctx.fillStyle = PAL.lightGray;
    ctx.font = '9px "Press Start 2P"';
    ctx.fillText('SPACE to continue', W / 2, H - 28);
  }

  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';
}

// ========== TITLE SCREEN ==========
function drawTitleScreen() {
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 40; i++) {
    const sx = (i * 37 + Math.sin(frameCount * 0.01 + i) * 10) % W;
    const sy = (i * 53 + Math.cos(frameCount * 0.01 + i) * 6) % H;
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(frameCount * 0.03 + i) * 0.3 + 0.5})`;
    ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
  }

  // Title
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '20px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText('ICONOCLAST', W / 2, 100);
  ctx.fillStyle = PAL.white;
  ctx.font = '14px "Press Start 2P"';
  ctx.fillText('Find Your Guide', W / 2, 130);
  ctx.fillStyle = PAL.lightGray;
  ctx.font = '9px "Press Start 2P"';
  ctx.fillText('(Before your group chat does)', W / 2, 148);

  // Wizard preview (centered, larger)
  ctx.textAlign = 'left';
  const wizImgTitle = SPRITE_CANVASES['wizard'];
  if (wizImgTitle) {
    const ws = 64; // 2x scale
    const bob = Math.sin(frameCount * 0.03) * 3;
    // Glow behind wizard
    const gAlpha = Math.sin(frameCount * 0.02) * 0.08 + 0.15;
    ctx.fillStyle = `rgba(244, 208, 63, ${gAlpha})`;
    ctx.beginPath();
    ctx.arc(W/2, 180 + bob, 40, 0, Math.PI * 2);
    ctx.fill();
    ctx.drawImage(wizImgTitle, 0, 0, SF, SF, W/2 - ws/2, 148 + bob, ws, ws);
  } else {
    drawSprite(7, 5, 'wizard', 0, 0);
  }

  // Life stage selection
  ctx.fillStyle = PAL.accent;
  ctx.font = '12px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText("Who are you?", W / 2, 270);

  for (let i = 0; i < LIFE_STAGES.length; i++) {
    const selected = i === titleSelection;
    ctx.fillStyle = selected ? PAL.wizardGold : PAL.gray;
    const prefix = selected ? '► ' : '  ';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(prefix + LIFE_STAGES[i], W / 2, 310 + i * 36);
  }

  ctx.fillStyle = PAL.lightGray;
  ctx.font = '10px "Press Start 2P"';
  ctx.fillText('↑↓ choose  SPACE start', W / 2, H - 30);

  ctx.textAlign = 'left';
}

// ========== CHARACTER SELECT SCREEN ==========
function drawCharSelect() {
  charSelectAnimTimer++;
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, W, H);

  // Subtle stars (same as title)
  for (let i = 0; i < 40; i++) {
    const sx = (i * 37 + Math.sin(frameCount * 0.01 + i) * 10) % W;
    const sy = (i * 53 + Math.cos(frameCount * 0.01 + i) * 6) % H;
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(frameCount * 0.03 + i) * 0.3 + 0.3})`;
    ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
  }

  const arch = ARCHETYPES[charSelectIndex];
  ctx.textAlign = 'center';

  // Header
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '12px "Press Start 2P"';
  ctx.fillText('CHOOSE YOUR ARCHETYPE', W / 2, 36);

  // Dot indicators for which character (top)
  for (let i = 0; i < ARCHETYPES.length; i++) {
    const dotX = W / 2 - (ARCHETYPES.length - 1) * 12 / 2 + i * 12;
    ctx.fillStyle = i === charSelectIndex ? arch.color : 'rgba(255,255,255,0.2)';
    ctx.beginPath();
    ctx.arc(dotX, 56, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  // Character sprite (large, centered) - uses canvas-drawn system
  const spriteSheet = SPRITE_CANVASES[arch.sprite];
  if (spriteSheet) {
    const scale = 4; // 128px from 32px
    const spriteSize = SF * scale;
    const bob = Math.sin(charSelectAnimTimer * 0.04) * 3;
    const cx = W / 2 - spriteSize / 2;
    const cy = 74 + bob;

    // Glow circle behind character in archetype color
    const r = parseInt(arch.color.slice(1,3), 16);
    const g = parseInt(arch.color.slice(3,5), 16);
    const b = parseInt(arch.color.slice(5,7), 16);
    const glowAlpha = Math.sin(charSelectAnimTimer * 0.03) * 0.08 + 0.18;
    ctx.fillStyle = `rgba(${r},${g},${b},${glowAlpha})`;
    ctx.beginPath();
    ctx.arc(W / 2, cy + spriteSize / 2, 56, 0, Math.PI * 2);
    ctx.fill();

    // Shadow under sprite
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(W / 2, cy + spriteSize + 4 + bob, 28, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Draw idle animation frame (row 0, first 2 frames = idle)
    const idleFrame = Math.floor(charSelectAnimTimer / 12) % 2;
    ctx.drawImage(spriteSheet, idleFrame * SF, 0, SF, SF, cx, cy, spriteSize, spriteSize);
  }

  // Left/Right arrows
  const arrowBob = Math.sin(charSelectAnimTimer * 0.06) * 3;
  ctx.fillStyle = PAL.white;
  ctx.font = '20px "Press Start 2P"';
  ctx.textAlign = 'left';
  ctx.fillText('◄', 16 + arrowBob, 160);
  ctx.textAlign = 'right';
  ctx.fillText('►', W - 16 - arrowBob, 160);

  // Name plate - dark box with colored accent border
  const plateY = 248;
  const plateH = 140;
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(24, plateY, W - 48, plateH);
  // Colored top border
  ctx.fillStyle = arch.color;
  ctx.fillRect(24, plateY, W - 48, 3);

  // Archetype name
  ctx.textAlign = 'center';
  ctx.fillStyle = arch.color;
  ctx.font = '16px "Press Start 2P"';
  ctx.fillText(arch.name, W / 2, plateY + 28);

  // Title
  ctx.fillStyle = PAL.white;
  ctx.font = '11px "Press Start 2P"';
  ctx.fillText(arch.title, W / 2, plateY + 50);

  // Description (auto-wrapped)
  ctx.fillStyle = PAL.lightGray;
  const descLines = wrapText(arch.desc, W - 100, 9);
  for (let i = 0; i < descLines.length; i++) {
    ctx.fillText(descLines[i], W / 2, plateY + 74 + i * 18);
  }

  // Tagline (italicized via lighter color)
  ctx.fillStyle = `rgba(${parseInt(arch.color.slice(1,3),16)},${parseInt(arch.color.slice(3,5),16)},${parseInt(arch.color.slice(5,7),16)},0.6)`;
  ctx.font = '8px "Press Start 2P"';
  ctx.fillText(`"${arch.tagline}"`, W / 2, plateY + 122);

  // Instructions
  ctx.fillStyle = PAL.lightGray;
  ctx.font = '9px "Press Start 2P"';
  ctx.fillText('◄ ► choose    SPACE select', W / 2, H - 20);

  ctx.textAlign = 'left';
}

// ========== INTERACTIVE WIZARD SYSTEM ==========
let wizardPhase = 0;
let wizardAnswers = [];
let wizardQuizData = null;

function triggerEnding() {
  wizardPhase = 1;
  wizardAnswers = [];
  stopMusic();
  dialogueNpcType = 'wizard';
  // Magical reveal sound
  for (let i = 0; i < 12; i++) {
    playNote(330 + i * 40, 0.3, 'triangle', 0.05, i * 0.08);
  }
  showDialogue([
    "...",
    "I've been watching.",
    "You didn't quit. That puts\nyou ahead of most people\nI meet. Seriously.",
    "Before I say what I see,\nI need to ask you two things.\nAnswer honestly — I'll know\nif you don't."
  ]);
  gameState = 'dialogue';
}

function advanceWizardPhase() {
  wizardPhase++;

  if (wizardPhase === 2) {
    // Wizard Question 1
    wizardQuizData = {
      question: "Be real with me.\nWhat actually scares you\nabout your money?",
      options: [
        "Running out before I'm done",
        "Something happening to me\n  and no one has a plan",
        "Making one stupid mistake\n  that costs everything",
        "Having no idea who to trust"
      ]
    };
    quizSelection = 0;
    gameState = 'quiz';
  }
  else if (wizardPhase === 3) {
    // Wizard Question 2
    wizardQuizData = {
      question: "If you could snap your\nfingers and fix ONE thing\nabout your finances...",
      options: [
        "Someone to untangle this\n  mess I've been ignoring",
        "A plan I can actually\n  explain to my spouse",
        "Knowing my family isn't\n  screwed if something\n  happens to me",
        "Just... confidence. That\n  I'm not quietly ruining\n  everything."
      ]
    };
    quizSelection = 0;
    gameState = 'quiz';
  }
  else if (wizardPhase === 4) {
    // --- Build personalized guidance from ALL answers ---
    // Life stage (from title): titleSelection 0/1/2
    // Zone answers: quizAnswers[1..3] (media/opinion/worry)
    // Wizard answers: wizardAnswers[0] (fear) wizardAnswers[1] (need)

    const fear = wizardAnswers[0] || 0;
    const need = wizardAnswers[1] || 0;

    // Opening line based on life stage
    let opener = "";
    if (titleSelection === 0) opener = "You're early. That's the\none unfair advantage nobody\ncan buy. Don't waste it\nby doing nothing.";
    else if (titleSelection === 1) opener = "You're in the thick of it.\nKids, career, mortgage,\nexistential dread.\nThe usual combo meal.";
    else opener = "You've built something real.\nNow the question is whether\nit survives you. That's not\nmorbid. That's math.";

    // Core insight based on fear
    const fearInsights = [
      "Retirement isn't some vague\nfuture problem. It's a math\nproblem. We solve those.\nThat's literally our job.",
      "If something happens to you\ntomorrow, does your family\nknow the plan? No? Then\nthere IS no plan.",
      "The fear of making one wrong\nmove has you making the worst\nmove of all: nothing.\nInaction isn't safe. It's\njust slow failure.",
      "Trust isn't vibes. It's\nstructure. Fee-only.\nFiduciary. We answer to you.\nNot a quota. Not a product\ncompany. You."
    ];

    // Actionable guidance based on need
    const needGuidance = [
      "We take the 47 open tabs\nin your brain and turn them\ninto one clear plan.\nNo jargon. No runaround.",
      "If your spouse's eyes glaze\nover when you explain the\nplan, the plan sucks.\nOurs don't.",
      "We build the safety net\nfirst. Because everything\nelse is decoration if that\nfoundation has holes.",
      "Confidence isn't a feeling.\nIt's what happens when the\nnumbers actually add up and\nsomeone shows you the math."
    ];

    // Play warm resolution sound
    playNote(330, 0.3, 'triangle', 0.06);
    playNote(440, 0.3, 'triangle', 0.06, 0.2);
    playNote(524, 0.4, 'triangle', 0.06, 0.4);

    showDialogue([
      opener,
      "You walked through the\nMedia Swamp, where fear is\npackaged and sold at scale.",
      "You survived the Opinion\nForest, where everyone's a\nfinancial genius until you\nask for their returns.",
      "You climbed the Worry\nMountains, where your own\nbrain tried to talk you out\nof getting help.",
      fearInsights[fear],
      needGuidance[need],
      "No commissions. No kickbacks.\nNo 'free dinner seminars.'\nJust someone who actually\ndoes this for a living.",
      "But first... let's see if\nyou actually learned anything\nor just clicked through.",
      "FEAR has one last move.\nLet's finish this."
    ]);
    gameState = 'dialogue';
  }
  else if (wizardPhase >= 5) {
    // Start the mini-game boss fight
    if (!minigameState) {
      minigameState = 'active';
      minigameQuestion = 0;
      minigameSelection = 0;
      initFearBoss();
      gameState = 'minigame';
      // Play boss encounter sound
      playNote(150, 0.3, 'sawtooth', 0.06);
      playNote(180, 0.3, 'sawtooth', 0.06, 0.2);
      playNote(200, 0.4, 'sawtooth', 0.04, 0.4);
    } else if (minigameState === 'won') {
      // Mini-game completed — show stats, then victory
      gameState = 'stats';
      statsTimer = 0;
    }
  }
}

// ========== CONFETTI SYSTEM ==========
function spawnConfetti() {
  confettiParticles = [];
  const colors = ['#f4d03f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#e67e22', '#1abc9c', '#ff6b9d'];
  for (let i = 0; i < 80; i++) {
    confettiParticles.push({
      x: W / 2 + (Math.random() - 0.5) * 100,
      y: H / 3,
      vx: (Math.random() - 0.5) * 8,
      vy: -Math.random() * 8 - 2,
      color: colors[Math.floor(Math.random() * colors.length)],
      size: Math.random() * 6 + 3,
      life: 120 + Math.random() * 60
    });
  }
}

function drawConfetti() {
  for (const p of confettiParticles) {
    const alpha = Math.min(1, p.life / 30);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size * 0.6);
    ctx.globalAlpha = 1;
  }
}

// ========== MINI-GAME: BOSS FIGHT VS FEAR (NEW VISUALS) ==========
function drawMinigameNew() {
  ctx.fillStyle = 'rgba(10,0,0,0.97)';
  ctx.fillRect(0, 0, W, H);

  // Vignette edges
  const vigGrad = ctx.createRadialGradient(W/2, H/2, 100, W/2, H/2, 340);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, W, H);

  // Calculate visual health (smooth drain)
  const targetHealth = 1 - (minigameQuestion / MINIGAME_QUESTIONS.length);
  fearHealth += (targetHealth - fearHealth) * 0.05;

  // Draw FEAR entity
  drawFearEntity(W / 2, 70, fearHealth);

  // Boss health bar
  ctx.fillStyle = '#222';
  ctx.fillRect(60, 120, W - 120, 10);
  const barColor = fearHealth > 0.5 ? '#cc3333' : fearHealth > 0.25 ? '#cc6633' : '#cccc33';
  ctx.fillStyle = barColor;
  ctx.fillRect(60, 120, (W - 120) * Math.max(0, fearHealth), 10);
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.strokeRect(60, 120, W - 120, 10);

  ctx.textAlign = 'center';
  ctx.fillStyle = PAL.lightGray;
  ctx.font = '8px "Press Start 2P"';
  ctx.fillText(`${minigameQuestion}/${MINIGAME_QUESTIONS.length} DEFEATED`, W / 2, 148);

  const q = MINIGAME_QUESTIONS[minigameQuestion];

  // Question
  ctx.fillStyle = '#ff8888';
  ctx.font = '11px "Press Start 2P"';
  const qLines = q.question.split('\n');
  for (let i = 0; i < qLines.length; i++) {
    ctx.fillText(qLines[i], W / 2, 180 + i * 22);
  }

  // Options
  const startY = 270;
  for (let i = 0; i < q.options.length; i++) {
    const selected = i === minigameSelection;
    ctx.fillStyle = selected ? PAL.wizardGold : PAL.gray;
    ctx.font = '10px "Press Start 2P"';
    const prefix = selected ? '► ' : '  ';
    const optLines = q.options[i].split('\n');
    for (let j = 0; j < optLines.length; j++) {
      ctx.fillText(prefix + optLines[j], W / 2, startY + i * 44 + j * 16);
    }
    if (selected) {
      ctx.fillStyle = 'rgba(226,183,20,0.08)';
      ctx.fillRect(16, startY + i * 44 - 14, W - 32, 26);
    }
  }

  ctx.fillStyle = PAL.lightGray;
  ctx.font = '9px "Press Start 2P"';
  ctx.fillText('↑↓ choose  SPACE attack', W / 2, H - 20);

  ctx.textAlign = 'left';

  // Wrong answer overlay
  if (minigameWrongMsg && minigameWrongTimer > 0) {
    ctx.fillStyle = 'rgba(139,58,58,0.92)';
    ctx.fillRect(20, H / 2 + 40, W - 40, 50);
    ctx.strokeStyle = '#ff6666';
    ctx.lineWidth = 2;
    ctx.strokeRect(22, H / 2 + 42, W - 44, 46);
    ctx.fillStyle = '#ffaaaa';
    ctx.font = '9px "Press Start 2P"';
    ctx.textAlign = 'center';
    const wLines = minigameWrongMsg.split('\n');
    for (let i = 0; i < wLines.length; i++) {
      ctx.fillText(wLines[i], W / 2, H / 2 + 62 + i * 16);
    }
    ctx.textAlign = 'left';
  }
}

// Keep old drawMinigame as reference but unused
function drawMinigame() { drawMinigameNew(); }

// ========== VICTORY SCREEN ==========
function drawVictoryScreen() {
  victoryTimer++;

  ctx.fillStyle = 'rgba(10,10,26,0.97)';
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 50; i++) {
    const sx = (i * 37 + Math.sin(frameCount * 0.01 + i) * 10) % W;
    const sy = (i * 53 + Math.cos(frameCount * 0.01 + i) * 6) % H;
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(frameCount * 0.03 + i) * 0.3 + 0.4})`;
    ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
  }

  // Certificate border
  const fadeIn = Math.min(1, victoryTimer / 30);
  ctx.globalAlpha = fadeIn;

  // Outer gold border
  ctx.strokeStyle = PAL.wizardGold;
  ctx.lineWidth = 4;
  ctx.strokeRect(30, 20, W - 60, H - 50);
  // Inner border
  ctx.strokeStyle = 'rgba(244,208,63,0.4)';
  ctx.lineWidth = 1;
  ctx.strokeRect(38, 28, W - 76, H - 66);

  ctx.textAlign = 'center';

  // Badge glow
  const badgeGlow = Math.sin(frameCount * 0.04) * 0.1 + 0.25;
  ctx.fillStyle = `rgba(244, 208, 63, ${badgeGlow})`;
  ctx.beginPath();
  ctx.arc(W / 2, 80, 35, 0, Math.PI * 2);
  ctx.fill();

  // Shield/badge shape
  ctx.fillStyle = PAL.wizardGold;
  ctx.beginPath();
  ctx.moveTo(W/2 - 20, 60);
  ctx.lineTo(W/2 + 20, 60);
  ctx.lineTo(W/2 + 22, 85);
  ctx.lineTo(W/2, 100);
  ctx.lineTo(W/2 - 22, 85);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#0a0a1a';
  ctx.font = '16px "Press Start 2P"';
  ctx.fillText('★', W/2, 87);

  // Title
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '10px "Press Start 2P"';
  ctx.fillText('— CERTIFICATE OF CLARITY —', W / 2, 130);

  // Main title
  ctx.fillStyle = PAL.white;
  ctx.font = '16px "Press Start 2P"';
  ctx.fillText('CERTIFIED', W / 2, 170);
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '18px "Press Start 2P"';
  ctx.fillText('ICONOCLAST', W / 2, 200);

  // Archetype line
  if (selectedArchetype) {
    const ar = parseInt(selectedArchetype.color.slice(1,3), 16);
    const ag = parseInt(selectedArchetype.color.slice(3,5), 16);
    const ab = parseInt(selectedArchetype.color.slice(5,7), 16);
    ctx.fillStyle = selectedArchetype.color;
    ctx.font = '9px "Press Start 2P"';
    ctx.fillText(`${selectedArchetype.name} — ${selectedArchetype.title}`, W / 2, 222);
  }

  // Subtitle
  ctx.fillStyle = PAL.lightGray;
  ctx.font = '9px "Press Start 2P"';
  ctx.fillText('You walked through the panic.', W / 2, 248);
  ctx.fillText('You ignored the bad takes.', W / 2, 268);
  ctx.fillText('You told Fear to sit down.', W / 2, 288);
  ctx.fillText('Not bad.', W / 2, 308);

  // Insight bonus
  if (insightCount > 0) {
    ctx.fillStyle = PAL.accent;
    ctx.font = '9px "Press Start 2P"';
    ctx.fillText(`✦ ${insightCount} Hidden Insight${insightCount > 1 ? 's' : ''} Found ✦`, W / 2, 333);
  }

  // CTA buttons
  if (victoryTimer > 60) {
    const ctaFade = Math.min(1, (victoryTimer - 60) / 30);
    ctx.globalAlpha = ctaFade;

    // Primary CTA
    const btnPulse = Math.sin(frameCount * 0.04) * 2;
    const btnY = 358 + btnPulse;
    ctx.fillStyle = PAL.wizardGold;
    ctx.fillRect(60, btnY, W - 120, 36);
    ctx.fillStyle = '#0a0a1a';
    ctx.font = '10px "Press Start 2P"';
    ctx.fillText("TALK TO A REAL GUIDE →", W / 2, btnY + 23);

    // Secondary
    ctx.fillStyle = PAL.gray;
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('SPACE / Click to continue', W / 2, H - 30);

    ctx.globalAlpha = 1;
  }

  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // Confetti on top
  drawConfetti();
}

function drawEndingCTA() {
  ctx.fillStyle = 'rgba(10,10,26,0.95)';
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 50; i++) {
    const sx = (i * 37 + Math.sin(frameCount * 0.01 + i) * 10) % W;
    const sy = (i * 53 + Math.cos(frameCount * 0.01 + i) * 6) % H;
    ctx.fillStyle = `rgba(255,255,255,${Math.sin(frameCount * 0.03 + i) * 0.3 + 0.4})`;
    ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
  }

  // Large warm glow behind wizard
  const glow = Math.sin(frameCount * 0.02) * 0.08 + 0.2;
  ctx.fillStyle = `rgba(244, 208, 63, ${glow})`;
  ctx.beginPath();
  ctx.arc(W / 2, 100, 70, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(74, 144, 217, ${glow * 0.5})`;
  ctx.beginPath();
  ctx.arc(W / 2, 100, 90, 0, Math.PI * 2);
  ctx.fill();

  // Wizard (drawn larger for CTA)
  const wizImg = SPRITE_CANVASES['wizard'];
  if (wizImg) {
    const wizSize = 96; // 3x scale
    ctx.drawImage(wizImg, 0, 0, SF, SF, W/2 - wizSize/2, 52, wizSize, wizSize);
  } else {
    drawSprite(7, 2, 'wizard', 0, 0);
  }

  ctx.textAlign = 'center';

  // Title
  ctx.fillStyle = PAL.wizardGold;
  ctx.font = '11px "Press Start 2P"';
  ctx.fillText('THE ICONOCLASTIC GUIDE', W / 2, 175);

  ctx.fillStyle = PAL.white;
  ctx.font = '14px "Press Start 2P"';
  ctx.fillText("You made it. Now what?", W / 2, 210);

  // Subtitle
  ctx.fillStyle = PAL.lightGray;
  ctx.font = '9px "Press Start 2P"';
  ctx.fillText('Iconoclastic Capital', W / 2, 250);
  ctx.fillText('Fee-Only. Fiduciary.', W / 2, 270);
  ctx.fillText('No BS.', W / 2, 290);

  // CTA Button
  const btnPulse = Math.sin(frameCount * 0.04) * 3;
  const btnY = 316 + btnPulse;
  // Button glow
  ctx.fillStyle = `rgba(244, 208, 63, 0.15)`;
  ctx.fillRect(70, btnY - 6, W - 140, 62);
  // Button
  ctx.fillStyle = PAL.wizardGold;
  ctx.fillRect(80, btnY, W - 160, 50);
  ctx.fillStyle = '#0a0a1a';
  ctx.font = '12px "Press Start 2P"';
  ctx.fillText("SEE IF WE'RE A FIT →", W / 2, btnY + 32);

  ctx.fillStyle = PAL.gray;
  ctx.font = '9px "Press Start 2P"';
  ctx.fillText('CLICK or press SPACE', W / 2, H - 24);

  ctx.textAlign = 'left';
}

// ========== ZONE NAME OVERLAY ==========
let zoneNameTimer = 0;
function drawZoneName() {
  if (zoneNameTimer > 0) {
    const alpha = zoneNameTimer > 40 ? 1 : zoneNameTimer / 40;
    ctx.fillStyle = `rgba(0,0,0,${alpha * 0.7})`;
    ctx.fillRect(0, H / 2 - 36, W, 50);
    ctx.fillStyle = `rgba(232,232,232,${alpha})`;
    ctx.font = '16px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(ZONES[currentZone].name, W / 2, H / 2 - 4);
    ctx.textAlign = 'left';
    zoneNameTimer--;
  }
}

// ========== SETUP & MAIN LOOP ==========
function setupZone() {
  const z = ZONES[currentZone];
  player.x = z.playerStart.x;
  player.y = z.playerStart.y;
  player.targetX = player.x;
  player.targetY = player.y;
  player.px = player.x * TILE;
  player.py = player.y * TILE;
  player.isMoving = false;
  player.moveProgress = 0;
  player.dir = 1; // face up
  npcs = z.npcs ? z.npcs.map(n => ({ ...n, talked: false, proximityTriggered: false, proximityTimer: 0 })) : [];
  zoneNameTimer = 80;
  // Spawn ambient particles for this zone
  spawnAmbientParticles(currentZone);
  // Track game start
  if (currentZone === 0 && gameStartTime === 0) {
    gameStartTime = Date.now();
  }
}

function handleInput() {
  if (gameState === 'title') {
    // handled in keydown
  }
  else if (gameState === 'playing') {
    // Smooth movement: interpolate pixel position toward target
    if (player.isMoving) {
      player.moveProgress += MOVE_SPEED;
      player.frame += 0.5; // animate walk cycle

      // Interpolate pixel position
      const startX = player.x * TILE;
      const startY = player.y * TILE;
      const endX = player.targetX * TILE;
      const endY = player.targetY * TILE;
      player.px = startX + (endX - startX) * Math.min(player.moveProgress, 1);
      player.py = startY + (endY - startY) * Math.min(player.moveProgress, 1);

      // Step sound mid-movement
      if (player.moveProgress >= 0.5 && player.moveProgress - MOVE_SPEED < 0.5) {
        playSfxStep();
      }

      if (player.moveProgress >= 1) {
        // Arrived at target tile
        player.x = player.targetX;
        player.y = player.targetY;
        player.px = player.x * TILE;
        player.py = player.y * TILE;
        player.isMoving = false;
        player.moveProgress = 0;
        player.moving = true;
        totalSteps++;

        // Check exit
        const z = ZONES[currentZone];
        if (z.exitTile && player.x === z.exitTile.x && player.y === z.exitTile.y) {
          if (z.quiz) {
            showQuiz(z.quiz);
          } else {
            startTransition(() => {
              currentZone++;
              setupZone();
            });
          }
          return;
        }

        // Check quiz trigger
        if (z.quiz && player.x === z.quiz.trigger.x && player.y === z.quiz.trigger.y) {
          showQuiz(z.quiz);
          return;
        }

        // Check wizard
        if (currentZone === 4 && z.wizard && wizardPhase === 0) {
          const dist = Math.abs(player.x - z.wizard.x) + Math.abs(player.y - z.wizard.y);
          if (dist <= 2) {
            triggerEnding();
            return;
          }
        }

        // If key still held, immediately queue next move
        tryStartMove();
      }
    } else {
      // Not currently moving — check for new input
      tryStartMove();
    }
  }
}

function tryStartMove() {
  let dx = 0, dy = 0;
  if (keysDown['ArrowUp'] || keysDown['w'] || keysDown['W']) { dy = -1; player.dir = 1; }
  else if (keysDown['ArrowDown'] || keysDown['s'] || keysDown['S']) { dy = 1; player.dir = 0; }
  else if (keysDown['ArrowLeft'] || keysDown['a'] || keysDown['A']) { dx = -1; player.dir = 2; }
  else if (keysDown['ArrowRight'] || keysDown['d'] || keysDown['D']) { dx = 1; player.dir = 3; }

  if (dx !== 0 || dy !== 0) {
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (isWalkable(nx, ny)) {
      player.targetX = nx;
      player.targetY = ny;
      player.isMoving = true;
      player.moveProgress = 0;
      player.moving = true;
    } else {
      // Bump: face the direction but don't move
      player.moving = false;
    }
  } else {
    player.moving = false;
  }
}

function interact() {
  if (interactCooldown > 0) return;
  interactCooldown = 10;

  if (gameState === 'dialogue') {
    if (!currentDialogue && dialogueQueue.length === 0) {
      // Dialogue fully done — advance wizard if we're in wizard flow
      if (currentZone === 4 && wizardPhase > 0 && wizardPhase < 5) {
        advanceWizardPhase();
      }
      return;
    }
    playSfxInteract();
    advanceDialogue();
    return;
  }

  if (gameState === 'quiz') {
    // Check if this is the wizard's quiz
    if (currentZone === 4 && wizardQuizData) {
      wizardAnswers.push(quizSelection);
      quizAnswers.push({
        question: wizardQuizData.question,
        answer: wizardQuizData.options[quizSelection],
        index: quizSelection
      });
      wizardQuizData = null;
      playSfxQuizConfirm();
      // After Q1 (phase 2), advance to phase 3 (Q2)
      // After Q2 (phase 3), advance to phase 4 (guidance)
      advanceWizardPhase();
    } else {
      playSfxQuizConfirm();
      selectQuizAnswer();
    }
    return;
  }

  if (gameState === 'ending') {
    window.open('https://iconocapital.com/get-started', '_blank');
    return;
  }

  if (gameState === 'playing') {
    // Check for NPC interaction
    const facingX = player.x + (player.dir === 2 ? -1 : player.dir === 3 ? 1 : 0);
    const facingY = player.y + (player.dir === 1 ? -1 : player.dir === 0 ? 1 : 0);

    for (const npc of npcs) {
      if (npc.x === facingX && npc.y === facingY) {
        playSfxInteract();
        dialogueNpcType = npc.type;
        showDialogue(npc.lines);
        if (!npc.talked) npcsEncountered++;
        npc.talked = true;
        // Easter egg insight bonus
        if (npc.easterEgg && !npc.insightClaimed) {
          npc.insightClaimed = true;
          insightCount++;
          // Play sparkle sound
          playNote(600, 0.1, 'square', 0.06);
          playNote(800, 0.1, 'square', 0.06, 0.1);
        }
        return;
      }
      // Also check if standing adjacent
      const dist = Math.abs(player.x - npc.x) + Math.abs(player.y - npc.y);
      if (dist <= 2) {
        playSfxInteract();
        dialogueNpcType = npc.type;
        showDialogue(npc.lines);
        if (!npc.talked) npcsEncountered++;
        npc.talked = true;
        if (npc.easterEgg && !npc.insightClaimed) {
          npc.insightClaimed = true;
          insightCount++;
          playNote(600, 0.1, 'square', 0.06);
          playNote(800, 0.1, 'square', 0.06, 0.1);
        }
        return;
      }
    }
  }
}

function update() {
  frameCount++;
  if (interactCooldown > 0) interactCooldown--;
  if (quizWrongTimer > 0) quizWrongTimer--;
  if (minigameWrongTimer > 0) minigameWrongTimer--;

  // Music crossfade
  updateMusicFade();

  // Ambient particles
  if (gameState === 'playing' || gameState === 'dialogue' || gameState === 'quiz') {
    updateAmbientParticles();
    // Update parallax based on player position
    parallaxOffset.x = player.px;
    parallaxOffset.y = player.py;
  }

  // Update confetti
  if (confettiParticles.length > 0) {
    confettiTimer++;
    for (const p of confettiParticles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.15; // gravity
      p.life--;
    }
    confettiParticles = confettiParticles.filter(p => p.life > 0);
  }

  if (gameState === 'transition') {
    updateTransition();
  }
  else if (gameState === 'playing') {
    handleInput();
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  if (gameState === 'intro') {
    drawIntro();
  }
  else if (gameState === 'title') {
    drawTitleScreen();
  }
  else if (gameState === 'charSelect') {
    drawCharSelect();
  }
  else if (gameState === 'minigame') {
    drawMinigameNew();
  }
  else if (gameState === 'stats') {
    drawStatsScreen();
  }
  else if (gameState === 'victory') {
    drawVictoryScreen();
  }
  else if (gameState === 'ending') {
    drawEndingCTA();
  }
  else {
    // Parallax background layer (behind everything)
    drawParallaxLayer(currentZone);

    drawZoneBackground(currentZone);

    // Ambient particles (behind NPCs, above ground)
    drawAmbientParticles(currentZone);

    // Draw NPCs
    for (const npc of npcs) {
      // Make NPCs face the player when close
      let npcDir = 0; // default face down
      const distToPlayer = Math.abs(player.x - npc.x) + Math.abs(player.y - npc.y);
      if (distToPlayer <= 3 && SPRITE_TYPES.has(npc.type)) {
        // Face toward player
        const dx = player.x - npc.x;
        const dy = player.y - npc.y;
        if (Math.abs(dx) > Math.abs(dy)) {
          npcDir = dx > 0 ? 3 : 2; // right or left
        } else {
          npcDir = dy > 0 ? 0 : 1; // down or up
        }
      }
      drawSprite(npc.x, npc.y, npc.type, npcDir, frameCount);

      // Draw interaction indicator for untouched character NPCs
      if (!npc.talked && SPRITE_TYPES.has(npc.type) && distToPlayer <= 4) {
        const bob = Math.sin(frameCount * 0.08) * 3;
        const ix = npc.x * TILE + 12;
        const iy = npc.y * TILE - CHAR_SIZE + TILE + 2 + bob; // above the scaled sprite head
        ctx.fillStyle = PAL.wizardGold;
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('!', ix, iy);
      }
    }

    // Draw wizard in zone 4
    if (currentZone === 4 && ZONES[4].wizard) {
      const wz = ZONES[4].wizard;
      // Wizard faces player when close
      let wzDir = 0;
      const distW = Math.abs(player.x - wz.x) + Math.abs(player.y - wz.y);
      if (distW <= 4) {
        const dx = player.x - wz.x;
        const dy = player.y - wz.y;
        if (Math.abs(dx) > Math.abs(dy)) {
          wzDir = dx > 0 ? 3 : 2;
        } else {
          wzDir = dy > 0 ? 0 : 1;
        }
      }
      drawSprite(wz.x, wz.y, 'wizard', wzDir, frameCount);

      // Wizard glow effect
      if (wizardPhase === 0) {
        const glowAlpha = Math.sin(frameCount * 0.03) * 0.1 + 0.15;
        ctx.fillStyle = `rgba(244, 208, 63, ${glowAlpha})`;
        ctx.beginPath();
        ctx.arc(wz.x * TILE + TILE / 2, wz.y * TILE, 36, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Draw player (using smooth pixel position)
    drawPlayerSmooth();

    // Zone name
    drawZoneName();

    // HUD
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, 26);
    ctx.fillStyle = PAL.wizardGold;
    ctx.font = '10px "Press Start 2P"';
    ctx.fillText(ZONES[currentZone].name, 8, 18);
    // Progress indicator
    ctx.fillStyle = PAL.lightGray;
    ctx.font = '9px "Press Start 2P"';
    const chapter = currentZone + 1;
    ctx.textAlign = 'right';
    ctx.fillText(`${chapter}/5`, W - 8, 18);
    // Progress dots
    for (let i = 0; i < 5; i++) {
      ctx.fillStyle = i < chapter ? PAL.wizardGold : 'rgba(255,255,255,0.2)';
      ctx.fillRect(W - 70 + i * 11, 10, 8, 8);
    }
    // Insight counter if > 0
    if (insightCount > 0) {
      ctx.fillStyle = PAL.accent;
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText(`✦${insightCount}`, W - 85, 18);
    }
    ctx.textAlign = 'left';

    // Dialogue
    if (gameState === 'dialogue') {
      drawDialogueBox();
    }
    // Quiz
    if (gameState === 'quiz') {
      drawQuiz();
    }
    // Transition
    if (gameState === 'transition') {
      drawTransition();
    }
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ========== INPUT HANDLING ==========
document.addEventListener('keydown', (e) => {
  keysDown[e.key] = true;
  initAudio();

  // Intro — skip on any key
  if (gameState === 'intro') {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      introTimer = INTRO_DURATION;
      gameState = 'title';
    }
    return;
  }

  // Stats screen — continue to victory
  if (gameState === 'stats') {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      gameState = 'victory';
      victoryTimer = 0;
      spawnConfetti();
      const fanfare = [330, 392, 494, 524, 587, 660, 784];
      fanfare.forEach((f, i) => playNote(f, 0.3, 'triangle', 0.06, i * 0.12));
    }
    return;
  }

  if (gameState === 'title') {
    if (e.key === 'ArrowUp' || e.key === 'w') {
      titleSelection = (titleSelection - 1 + LIFE_STAGES.length) % LIFE_STAGES.length;
      initAudio(); playSfxQuizSelect();
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      titleSelection = (titleSelection + 1) % LIFE_STAGES.length;
      initAudio(); playSfxQuizSelect();
    }
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      initAudio();
      playSfxQuizConfirm();
      quizAnswers = [{ question: 'Life Stage', answer: LIFE_STAGES[titleSelection], index: titleSelection }];
      gameState = 'charSelect';
      charSelectIndex = 0;
      charSelectAnimTimer = 0;
    }
  }
  else if (gameState === 'charSelect') {
    if (e.key === 'ArrowLeft' || e.key === 'a') {
      charSelectIndex = (charSelectIndex - 1 + ARCHETYPES.length) % ARCHETYPES.length;
      charSelectAnimTimer = 0;
      playSfxQuizSelect();
    }
    if (e.key === 'ArrowRight' || e.key === 'd') {
      charSelectIndex = (charSelectIndex + 1) % ARCHETYPES.length;
      charSelectAnimTimer = 0;
      playSfxQuizSelect();
    }
    // Also support up/down for accessibility
    if (e.key === 'ArrowUp' || e.key === 'w') {
      charSelectIndex = (charSelectIndex - 1 + ARCHETYPES.length) % ARCHETYPES.length;
      charSelectAnimTimer = 0;
      playSfxQuizSelect();
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      charSelectIndex = (charSelectIndex + 1) % ARCHETYPES.length;
      charSelectAnimTimer = 0;
      playSfxQuizSelect();
    }
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      playSfxQuizConfirm();
      selectedArchetype = ARCHETYPES[charSelectIndex];
      quizAnswers.push({ question: 'Archetype', answer: selectedArchetype.title, index: charSelectIndex });
      gameState = 'transition';
      transitionAlpha = 0;
      transitionDir = 1;
      transitionCallback = () => {
        currentZone = 0;
        setupZone();
      };
    }
  }
  else if (gameState === 'quiz') {
    const qd = (currentZone === 4 && wizardQuizData) ? wizardQuizData : quizData;
    if (e.key === 'ArrowUp' || e.key === 'w') {
      quizSelection = (quizSelection - 1 + qd.options.length) % qd.options.length;
      playSfxQuizSelect();
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      quizSelection = (quizSelection + 1) % qd.options.length;
      playSfxQuizSelect();
    }
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      interact();
    }
  }
  else if (gameState === 'minigame') {
    if (minigameWrongTimer > 0) return; // wait for wrong msg to clear
    const q = MINIGAME_QUESTIONS[minigameQuestion];
    if (e.key === 'ArrowUp' || e.key === 'w') {
      minigameSelection = (minigameSelection - 1 + q.options.length) % q.options.length;
      playSfxQuizSelect();
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      minigameSelection = (minigameSelection + 1) % q.options.length;
      playSfxQuizSelect();
    }
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      if (minigameSelection === q.correct) {
        // Correct — damage FEAR!
        playSfxQuizConfirm();
        fearShake = 12; // screen shake intensity
        addFearCrack(); // visual crack on boss
        // Damage stinger sound
        playNote(120, 0.15, 'sawtooth', 0.08);
        playNote(90, 0.2, 'sawtooth', 0.06, 0.1);
        minigameQuestion++;
        minigameSelection = 0;
        minigameWrongMsg = null;
        if (minigameQuestion >= MINIGAME_QUESTIONS.length) {
          // Won the boss fight!
          minigameState = 'won';
          advanceWizardPhase();
        }
      } else {
        // Wrong — show message, let them try again
        minigameWrongMsg = q.wrongMsg;
        minigameWrongTimer = 60;
        playNote(150, 0.2, 'sawtooth', 0.06);
      }
    }
  }
  else if (gameState === 'victory') {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      // Move to ending CTA
      gameState = 'ending';
    }
  }
  else if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    interact();
  }
});

document.addEventListener('keyup', (e) => {
  keysDown[e.key] = false;
});

// Mobile controls
function setupMobile() {
  const dirs = { 'btn-up': 'ArrowUp', 'btn-down': 'ArrowDown', 'btn-left': 'ArrowLeft', 'btn-right': 'ArrowRight' };
  for (const [id, key] of Object.entries(dirs)) {
    const btn = document.getElementById(id);
    if (!btn) continue;
    let holdInterval = null;
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      initAudio();
      keysDown[key] = true;
      // Dispatch synthetic keydown for title/quiz/minigame screens
      document.dispatchEvent(new KeyboardEvent('keydown', { key: key, bubbles: true }));
      if (holdInterval) clearInterval(holdInterval);
      holdInterval = setInterval(() => {
        document.dispatchEvent(new KeyboardEvent('keydown', { key: key, bubbles: true }));
      }, 200);
    }, { passive: false });
    const stopHold = (e) => {
      e.preventDefault();
      e.stopPropagation();
      keysDown[key] = false;
      if (holdInterval) { clearInterval(holdInterval); holdInterval = null; }
    };
    btn.addEventListener('touchend', stopHold, { passive: false });
    btn.addEventListener('touchcancel', stopHold, { passive: false });
    btn.addEventListener('touchmove', (e) => { e.preventDefault(); e.stopPropagation(); }, { passive: false });
    // Also support mouse for testing
    btn.addEventListener('mousedown', (e) => {
      e.preventDefault();
      keysDown[key] = true;
      document.dispatchEvent(new KeyboardEvent('keydown', { key: key, bubbles: true }));
      if (holdInterval) clearInterval(holdInterval);
      holdInterval = setInterval(() => {
        document.dispatchEvent(new KeyboardEvent('keydown', { key: key, bubbles: true }));
      }, 200);
    });
    btn.addEventListener('mouseup', (e) => {
      e.preventDefault();
      keysDown[key] = false;
      if (holdInterval) { clearInterval(holdInterval); holdInterval = null; }
    });
    btn.addEventListener('mouseleave', (e) => {
      keysDown[key] = false;
      if (holdInterval) { clearInterval(holdInterval); holdInterval = null; }
    });
  }

  const actionBtn = document.getElementById('action-btn');
  if (actionBtn) {
    actionBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      initAudio();
      if (gameState === 'intro') {
        introTimer = INTRO_DURATION;
        gameState = 'title';
      } else if (gameState === 'title') {
        playSfxQuizConfirm();
        quizAnswers = [{ question: 'Life Stage', answer: LIFE_STAGES[titleSelection], index: titleSelection }];
        gameState = 'charSelect';
        charSelectIndex = 0;
        charSelectAnimTimer = 0;
      } else if (gameState === 'charSelect') {
        playSfxQuizConfirm();
        selectedArchetype = ARCHETYPES[charSelectIndex];
        quizAnswers.push({ question: 'Archetype', answer: selectedArchetype.title, index: charSelectIndex });
        gameState = 'transition';
        transitionAlpha = 0;
        transitionDir = 1;
        transitionCallback = () => { currentZone = 0; setupZone(); };
      } else if (gameState === 'minigame') {
        if (minigameWrongTimer > 0) return;
        const q = MINIGAME_QUESTIONS[minigameQuestion];
        if (minigameSelection === q.correct) {
          playSfxQuizConfirm();
          fearShake = 12;
          addFearCrack();
          playNote(120, 0.15, 'sawtooth', 0.08);
          playNote(90, 0.2, 'sawtooth', 0.06, 0.1);
          minigameQuestion++;
          minigameSelection = 0;
          minigameWrongMsg = null;
          if (minigameQuestion >= MINIGAME_QUESTIONS.length) {
            minigameState = 'won';
            advanceWizardPhase();
          }
        } else {
          minigameWrongMsg = q.wrongMsg;
          minigameWrongTimer = 60;
          playNote(150, 0.2, 'sawtooth', 0.06);
        }
      } else if (gameState === 'stats') {
        gameState = 'victory';
        victoryTimer = 0;
        spawnConfetti();
        const fanfare = [330, 392, 494, 524, 587, 660, 784];
        fanfare.forEach((f, i) => playNote(f, 0.3, 'triangle', 0.06, i * 0.12));
      } else if (gameState === 'victory') {
        gameState = 'ending';
      } else {
        interact();
      }
    }, { passive: false });
    actionBtn.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
  }

  // Prevent iOS rubber-band scrolling and pull-to-refresh
  document.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
  document.addEventListener('gesturestart', (e) => { e.preventDefault(); }, { passive: false });
  document.addEventListener('gesturechange', (e) => { e.preventDefault(); }, { passive: false });
  document.addEventListener('gestureend', (e) => { e.preventDefault(); }, { passive: false });
}

// Canvas click for CTA
canvas.addEventListener('click', (e) => {
  initAudio();
  if (gameState === 'ending') {
    e.preventDefault();
    window.open('https://iconocapital.com/get-started', '_blank');
  } else if (gameState === 'victory') {
    gameState = 'ending';
  }
});

// Touch on canvas
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  initAudio();
  if (gameState === 'ending') {
    window.open('https://iconocapital.com/get-started', '_blank');
  } else if (gameState === 'victory') {
    gameState = 'ending';
  }
}, { passive: false });

setupMobile();
gameLoop();
</script>
</body>
</html>
